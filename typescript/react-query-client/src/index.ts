/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest
 * OpenAPI spec version: 1.0.4
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

/**
 * Address encoded using a 32-character set.
 */
export type Address = string;

/**
 * Absolute amount. An amount of 123456789 (absolute) for a mosaic with divisibility 6 means 123.456789 (relative).
 */
export type Amount = string;

/**
 * Duration expressed in number of blocks.
 */
export type BlockDuration = string;

/**
 * Fee multiplier applied to transactions contained in block.
 */
export type BlockFeeMultiplier = number;

/**
 * Cosignature version.
 */
export type CosignatureVersion = string;

/**
 * Determines how hard is to harvest a new block, based on previous blocks.
 */
export type Difficulty = string;

/**
 * Finalization Epoch
 */
export type FinalizationEpoch = number;

/**
 * Finalization point
 */
export type FinalizationPoint = number;

export type Hash256 = string;

/**
 * Height of the blockchain.
 */
export type Height = string;

/**
 * Finalized height of the blockchain.
 */
export type FinalizedHeight = string;

/**
 * Probability of an account to harvest the next block.
 */
export type Importance = string;

/**
 * Type of action:
* 0 - Unlink.
* 1 - Link.

 */
export type LinkActionEnum = typeof LinkActionEnum[keyof typeof LinkActionEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LinkActionEnum = {
  NUMBER_0: 0,
  NUMBER_1: 1,
} as const;

/**
 * Metadata key scoped to source, target and type expressed.
 */
export type MetadataKey = string;

/**
 * Metadata value. If embedded in a transaction, this is calculated as xor(previous-value, value).
 */
export type MetadataValue = string;

export interface ModelError {
  code: string;
  message: string;
}

/**
 * Mosaic identifier.
 */
export type MosaicId = string;

export interface Mosaic {
  id: MosaicId;
  amount: Amount;
}

export type MerkleStateInfoDTOTreeItem = MerkleTreeBranchDTO | MerkleTreeLeafDTO;

/**
 * The merkle path information clients can use to proof the state of the given entity.

 */
export interface MerkleStateInfoDTO {
  raw: MerkleTreeRaw;
  /** Merkle tree parsed from merkle tree raw. */
  tree: MerkleStateInfoDTOTreeItem[];
}

/**
 * The hex information of the complete merkle tree as returned by server api.
More information can be found in chapter 4.3 of the catapult whitepaper.

 */
export type MerkleTreeRaw = string;

/**
 * Merkle tree branch node.
 */
export interface MerkleTreeBranchDTO {
  /** Merkle tree node type. */
  type: MerkleTreeNodeTypeEnum;
  /** Branch link path. */
  path: string;
  /** Encoded branch link path. */
  encodedPath: string;
  /** Nibble count. */
  nibbleCount: number;
  /** Branch link bitmask. */
  linkMask: string;
  /** Branch links (max 16). */
  links: MerkleTreeBranchLinkDTO[];
  /** Hash of the branch node. */
  branchHash: Hash256;
}

/**
 * Merkle tree leaf node.
 */
export interface MerkleTreeLeafDTO {
  /** Merkle tree node type. */
  type: MerkleTreeNodeTypeEnum;
  /** Leaf path. */
  path: string;
  /** Encoded leaf path. */
  encodedPath: string;
  /** Nibble count. */
  nibbleCount: number;
  /** Leaf value (sha256 hash). */
  value: string;
  /** Hash of the leaf node. */
  leafHash: Hash256;
}

/**
 * Merkle tree branch link.
 */
export interface MerkleTreeBranchLinkDTO {
  /** Branch link nibble bit index (hexadecimal). */
  bit: string;
  /** Branch link hash. */
  link: Hash256;
}

/**
 * Type of Merkle tree node:
* 0 - Branch node.
* 255 - Leaf node.

 */
export type MerkleTreeNodeTypeEnum = typeof MerkleTreeNodeTypeEnum[keyof typeof MerkleTreeNodeTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MerkleTreeNodeTypeEnum = {
  NUMBER_0: 0,
  NUMBER_255: 255,
} as const;

/**
 * Restriction key.
 */
export type RestrictionKey = string;

/**
 * Namespace identifier.
 */
export type NamespaceId = string;

/**
 * Indicates how to sort the results: 
* ``asc`` - ascending
* ``desc`` - descending

 */
export type Order = typeof Order[keyof typeof Order];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const Order = {
  asc: 'asc',
  desc: 'desc',
} as const;

export interface Pagination {
  pageNumber: number;
  pageSize: number;
}

/**
 * Public key.
 */
export type PublicKey = string;

/**
 * 32-bytes VRF proof gamma.
 */
export type ProofGamma = string;

/**
 * 32-bytes VRF proof scalar.
 */
export type ProofScalar = string;

/**
 * 16-bytes VRF proof verification hash.
 */
export type ProofVerificationHash = string;

/**
 * Score of the blockchain. During synchronization, nodes try to get the
blockchain with highest score in the network.

 */
export type Score = string;

/**
 * Possible status of lock states:
* 0 - UNUSED.
* 1 - USED.

 */
export type LockStatus = typeof LockStatus[keyof typeof LockStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LockStatus = {
  NUMBER_0: 0,
  NUMBER_1: 1,
} as const;

/**
 * Secret.
 */
export type Secret = string;

/**
 * Entity's signature generated by the signer.
 */
export type Signature = string;

/**
 * The version of the state
 */
export type StateVersion = number;

/**
 * Number of milliseconds elapsed since the creation of the nemesis block. This value can be converted to epoch time by adding the network's 'epochAdjustment'.
 */
export type Timestamp = string;

/**
 * A number that allows uint 32 values.
 */
export type UInt32 = number;

/**
 * A number that allows uint 64 values represented with a string.
 */
export type UInt64 = string;

/**
 * Address expressed in Base32 format. If the bit 0 of byte 0 is not set (like in 0x90), then it is a
regular address. Example: TAOXUJOTTW3W5XTBQMQEX3SQNA6MCUVGXLXR3TA. 
Otherwise (e.g. 0x91) it represents a namespace id which starts at byte 1. Example: THBIMC3THGH5RUYAAAAAAAAAAAAAAAAAAAAAAAA

 */
export type UnresolvedAddress = string;

/**
 * Mosaic identifier. If the most significant bit of byte 0 is set, a namespaceId (alias)
is used instead of the real mosaic identifier.

 */
export type UnresolvedMosaicId = string;

export interface UnresolvedMosaic {
  id: UnresolvedMosaicId;
  amount: Amount;
}

/**
 * 32 bytes voting public key.
 */
export type VotingKey = string;

/**
 * Restriction value.
 */
export type RestrictionValue = string;

export type AccountOrderByEnum = typeof AccountOrderByEnum[keyof typeof AccountOrderByEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountOrderByEnum = {
  id: 'id',
  balance: 'balance',
} as const;

export interface AccountPage {
  /** Array of accounts. */
  data: AccountInfoDTO[];
  pagination: Pagination;
}

/**
 * * 0 - Unlinked.
* 1 - Balance-holding account that is linked to a remote harvester account.
* 2 - Remote harvester account that is linked to a balance-holding account.
* 3 - Remote harvester eligible account that is unlinked.

 */
export type AccountTypeEnum = typeof AccountTypeEnum[keyof typeof AccountTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountTypeEnum = {
  NUMBER_0: 0,
  NUMBER_1: 1,
  NUMBER_2: 2,
  NUMBER_3: 3,
} as const;

export interface AccountDTO {
  version: StateVersion;
  address: Address;
  addressHeight: Height;
  publicKey: PublicKey;
  publicKeyHeight: Height;
  accountType: AccountTypeEnum;
  supplementalPublicKeys: SupplementalPublicKeysDTO;
  activityBuckets: ActivityBucketDTO[];
  /** Mosaic units owned. */
  mosaics: Mosaic[];
  importance: Importance;
  importanceHeight: Height;
}

export interface AccountInfoDTO {
  /** Internal resource identifier. */
  id: string;
  account: AccountDTO;
}

/**
 * Supplementary data stored for importance recalculation.
At each importance recalculation, existing buckets are shifted, the working bucket is finalized and a new working bucket is created.
Each bucket influences at most five importance recalculations.

 */
export interface ActivityBucketDTO {
  startHeight: Height;
  /** Fees paid by the account for this bucket. */
  totalFeesPaid: Amount;
  /** Number of times the account has been a beneficiary for this bucket. */
  beneficiaryCount: UInt32;
  /** Importance score for this bucket. This is taken into account to calculate the latest account importance. */
  rawScore: Importance;
}

export interface AccountLinkPublicKeyDTO {
  publicKey: string;
}

export interface AccountLinkVotingKeysDTO {
  publicKeys: AccountLinkVotingKeyDTO[];
}

export interface AccountLinkVotingKeyDTO {
  publicKey: string;
  startEpoch: FinalizationEpoch;
  endEpoch: FinalizationEpoch;
}

export interface SupplementalPublicKeysDTO {
  linked?: AccountLinkPublicKeyDTO;
  node?: AccountLinkPublicKeyDTO;
  vrf?: AccountLinkPublicKeyDTO;
  voting?: AccountLinkVotingKeysDTO;
}

/**
 * Type of account key:
* 0 - Unset.
* 1 - Linked account public key.
* 2 - Node public key on which remote is allowed to harvest.
* 4 - VRF public key.

 */
export type AccountKeyTypeFlagsEnum = typeof AccountKeyTypeFlagsEnum[keyof typeof AccountKeyTypeFlagsEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountKeyTypeFlagsEnum = {
  NUMBER_0: 0,
  NUMBER_1: 1,
  NUMBER_2: 2,
  NUMBER_4: 4,
} as const;

export type BlockOrderByEnum = typeof BlockOrderByEnum[keyof typeof BlockOrderByEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const BlockOrderByEnum = {
  id: 'id',
  height: 'height',
} as const;

/**
 * Position relative to the proofHash being evaluated.
 */
export type PositionEnum = typeof PositionEnum[keyof typeof PositionEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PositionEnum = {
  left: 'left',
  right: 'right',
} as const;

export type BlockDTOAllOf = {
  height: Height;
  timestamp: Timestamp;
  difficulty: Difficulty;
  proofGamma: ProofGamma;
  proofVerificationHash: ProofVerificationHash;
  proofScalar: ProofScalar;
  previousBlockHash: Hash256;
  transactionsHash: Hash256;
  receiptsHash: Hash256;
  stateHash: Hash256;
  beneficiaryAddress: Address;
  feeMultiplier: BlockFeeMultiplier;
};

export type BlockDTO = SizePrefixedEntityDTO & VerifiableEntityDTO & EntityDTO & BlockDTOAllOf;

export type BlockInfoDTOBlock = BlockDTO | ImportanceBlockDTO;

export interface BlockInfoDTO {
  /** Internal resource identifier. */
  id: string;
  meta: BlockMetaDTO;
  block: BlockInfoDTOBlock;
}

export interface BlockMetaDTO {
  hash: Hash256;
  totalFee: Amount;
  generationHash: Hash256;
  stateHashSubCacheMerkleRoots: Hash256[];
  /** Total number of [transactions](https://docs.symbol.dev/concepts/transaction.html) confirmed in this block, including *embedded* transactions (i.e. transactions contained within aggregate transactions).
 */
  totalTransactionsCount: number;
  /** Number of [transactions](https://docs.symbol.dev/concepts/transaction.html) confirmed in this block. This does not count *embedded* transactions (i.e. transactions contained within aggregate transactions).
 */
  transactionsCount: number;
  /** Number of statements (of any kind) present in this block. Bear in mind that some of them (like [resolution statements](https://docs.symbol.dev/concepts/receipt.html#resolution-statement)) are triggered by transactions present in the block, but in general, [transaction statements](https://docs.symbol.dev/concepts/receipt.html#transaction-statement) are not.
 */
  statementsCount: number;
}

export interface BlockPage {
  /** Array of blocks. */
  data: BlockInfoDTO[];
  pagination: Pagination;
}

export type ImportanceBlockDTOAllOf = {
  /** Number of voting eligible accounts. */
  votingEligibleAccountsCount: UInt32;
  /** Number of harvesting eligible accounts. */
  harvestingEligibleAccountsCount: UInt64;
  /** Total balance eligible for voting. */
  totalVotingBalance: Amount;
  /** Previous importance block hash. */
  previousImportanceBlockHash: Hash256;
};

export type ImportanceBlockDTO = BlockDTO & ImportanceBlockDTOAllOf;

/**
 * Each merkle path item is composed of a hash, and a position relative to the proofHash being evaluated.
 */
export interface MerklePathItemDTO {
  position?: PositionEnum;
  hash?: Hash256;
}

export interface MerkleProofInfoDTO {
  /** List of complementary merkle path items needed to recalculate the merkle root. */
  merklePath?: MerklePathItemDTO[];
}

export interface ChainInfoDTO {
  height: Height;
  scoreHigh: Score;
  scoreLow: Score;
  latestFinalizedBlock: FinalizedBlockDTO;
}

export interface FinalizedBlockDTO {
  finalizationEpoch: FinalizationEpoch;
  finalizationPoint: FinalizationPoint;
  height: Height;
  hash: Hash256;
}

export interface RentalFeesDTO {
  /** Estimated effective rental fee to register/extend a namespace per block. */
  effectiveRootNamespaceRentalFeePerBlock: Amount;
  /** Estimated effective rental fee to create a subnamespace. */
  effectiveChildNamespaceRentalFee: Amount;
  /** Estimated effective rental fee to create a mosaic. */
  effectiveMosaicRentalFee: Amount;
}

export interface TransactionFeesDTO {
  /** Average fee multiplier over the last "numBlocksTransactionFeeStats" on the current Network. */
  averageFeeMultiplier: BlockFeeMultiplier;
  /** Median fee multiplier over the last "numBlocksTransactionFeeStats" on the current Network. */
  medianFeeMultiplier: BlockFeeMultiplier;
  /** Highest fee multiplier over the last "numBlocksTransactionFeeStats" on the current Network. */
  highestFeeMultiplier: BlockFeeMultiplier;
  /** Lowest fee multiplier over the last "numBlocksTransactionFeeStats" on the current Network. */
  lowestFeeMultiplier: BlockFeeMultiplier;
  /** Minimal fee multiplier on the current connected Node. */
  minFeeMultiplier: BlockFeeMultiplier;
}

/**
 * Network type:
* 0x60 (96 decimal) - Mijin network.
* 0x90 (144 decimal) - Mijin test network.
* 0x68 (104 decimal) - Main network.
* 0x98 (152 decimal) - Test network.

 */
export type NetworkTypeEnum = typeof NetworkTypeEnum[keyof typeof NetworkTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NetworkTypeEnum = {
  NUMBER_96: 96,
  NUMBER_144: 144,
  NUMBER_104: 104,
  NUMBER_152: 152,
} as const;

export interface EntityDTO {
  signerPublicKey: PublicKey;
  /** Entity version. */
  version: number;
  network: NetworkTypeEnum;
  type: number;
}

export interface SizePrefixedEntityDTO {
  /** Entity size in bytes. */
  size: UInt32;
}

export interface VerifiableEntityDTO {
  signature: Signature;
}

export interface BmTreeSignature {
  root: ParentPublicKeySignaturePair;
  bottom: ParentPublicKeySignaturePair;
}

export interface FinalizationProofDTO {
  version: number;
  finalizationEpoch: FinalizationEpoch;
  finalizationPoint: FinalizationPoint;
  height: Height;
  hash: Hash256;
  messageGroups: MessageGroup[];
}

export interface MessageGroup {
  /** Message stage */
  stage: StageEnum;
  /** Block height corresponding to the first hash. */
  height: Height;
  hashes: Hash256[];
  signatures: BmTreeSignature[];
}

export interface ParentPublicKeySignaturePair {
  parentPublicKey: PublicKey;
  signature: Signature;
}

/**
 * Type of stage:
* 0 - Prevote.
* 1 - Precommit.
* 2 - Count.

 */
export type StageEnum = typeof StageEnum[keyof typeof StageEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StageEnum = {
  NUMBER_0: 0,
  NUMBER_1: 1,
  NUMBER_2: 2,
} as const;

/**
 * Node equality strategy. Defines if the identifier for the node must be its public key or host.

 */
export type NodeIdentityEqualityStrategy = typeof NodeIdentityEqualityStrategy[keyof typeof NodeIdentityEqualityStrategy];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NodeIdentityEqualityStrategy = {
  host: 'host',
  'public-key': 'public-key',
} as const;

export interface NetworkTypeDTO {
  /** Network name. */
  name: string;
  /** A short text describing the network. */
  description: string;
}

/**
 * Chain related configuration properties.
 */
export interface ChainPropertiesDTO {
  /** Set to true if block chain should calculate state hashes so that state is fully verifiable at each block. */
  enableVerifiableState?: boolean;
  /** Set to true if block chain should calculate receipts so that state changes are fully verifiable at each block. */
  enableVerifiableReceipts?: boolean;
  /** Mosaic id used as primary chain currency. */
  currencyMosaicId?: string;
  /** Mosaic id used to provide harvesting ability. */
  harvestingMosaicId?: string;
  /** Targeted time between blocks. */
  blockGenerationTargetTime?: string;
  /** A higher value makes the network more biased. */
  blockTimeSmoothingFactor?: string;
  /** Number of blocks between successive finalization attempts. */
  blockFinalizationInterval?: string;
  /** Number of blocks that should be treated as a group for importance purposes. */
  importanceGrouping?: string;
  /** Percentage of importance resulting from fee generation and beneficiary usage. */
  importanceActivityPercentage?: string;
  /** Maximum number of blocks that can be rolled back. */
  maxRollbackBlocks?: string;
  /** Maximum number of blocks to use in a difficulty calculation. */
  maxDifficultyBlocks?: string;
  /** Default multiplier to use for dynamic fees. */
  defaultDynamicFeeMultiplier?: string;
  /** Maximum lifetime a transaction can have before it expires. */
  maxTransactionLifetime?: string;
  /** Maximum future time of a block that can be accepted. */
  maxBlockFutureTime?: string;
  /** Initial currency atomic units available in the network. */
  initialCurrencyAtomicUnits?: string;
  /** Maximum atomic units (total-supply * 10 ^ divisibility) of a mosaic allowed in the network. */
  maxMosaicAtomicUnits?: string;
  /** Total whole importance units available in the network. */
  totalChainImportance?: string;
  /** Minimum number of harvesting mosaic atomic units needed for an account to be eligible for harvesting. */
  minHarvesterBalance?: string;
  /** Maximum number of harvesting mosaic atomic units needed for an account to be eligible for harvesting. */
  maxHarvesterBalance?: string;
  /** Minimum number of harvesting mosaic atomic units needed for an account to be eligible for voting. */
  minVoterBalance?: string;
  /** Maximum number of voting keys that can be registered at once per account. */
  maxVotingKeysPerAccount?: string;
  /** Minimum number of finalization rounds for which voting key can be registered. */
  minVotingKeyLifetime?: string;
  /** Maximum number of finalization rounds for which voting key can be registered. */
  maxVotingKeyLifetime?: string;
  /** Percentage of the harvested fee that is collected by the beneficiary account. */
  harvestBeneficiaryPercentage?: string;
  /** Percentage of the harvested fee that is collected by the network. */
  harvestNetworkPercentage?: string;
  /** Address of the harvest network fee sink account. */
  harvestNetworkFeeSinkAddress?: Address;
  /** Number of blocks between cache pruning. */
  blockPruneInterval?: string;
  /** Maximum number of transactions per block. */
  maxTransactionsPerBlock?: string;
}

export interface NetworkConfigurationDTO {
  network: NetworkPropertiesDTO;
  chain: ChainPropertiesDTO;
  plugins: PluginsPropertiesDTO;
}

/**
 * Network related configuration properties.
 */
export interface NetworkPropertiesDTO {
  /** Network identifier. */
  identifier?: string;
  nodeEqualityStrategy?: NodeIdentityEqualityStrategy;
  /** Nemesis public key. */
  nemesisSignerPublicKey?: PublicKey;
  /** Seed for generating Nemesis generation hash. */
  generationHashSeed?: Hash256;
  /** Nemesis epoch time adjustment. */
  epochAdjustment?: string;
}

/**
 * Plugin related configuration properties.
 */
export interface PluginsPropertiesDTO {
  accountlink?: AccountKeyLinkNetworkPropertiesDTO;
  aggregate?: AggregateNetworkPropertiesDTO;
  lockhash?: HashLockNetworkPropertiesDTO;
  locksecret?: SecretLockNetworkPropertiesDTO;
  metadata?: MetadataNetworkPropertiesDTO;
  mosaic?: MosaicNetworkPropertiesDTO;
  multisig?: MultisigNetworkPropertiesDTO;
  namespace?: NamespaceNetworkPropertiesDTO;
  restrictionaccount?: AccountRestrictionNetworkPropertiesDTO;
  restrictionmosaic?: MosaicRestrictionNetworkPropertiesDTO;
  transfer?: TransferNetworkPropertiesDTO;
}

export type NodeStatusEnum = typeof NodeStatusEnum[keyof typeof NodeStatusEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NodeStatusEnum = {
  up: 'up',
  down: 'down',
} as const;

/**
 * A number that defines the different roles the node provides. Possible roles are:
* 1 - Peer node.
* 2 - Api node.
* 4 - Voting node.
* 64 - IPv4 compatible node
* 128 - IPv6 compatible node.

The values are bitwise added together, Examples:
1 = Just Peer.
2 = Just Api.
3 = Peer and Api node.
7 = Peer, Api and Voting node.
65 = IPv4 and Peer node.

 */
export type RolesTypeEnum = number;

export interface CommunicationTimestampsDTO {
  sendTimestamp?: Timestamp;
  receiveTimestamp?: Timestamp;
}

export interface DeploymentDTO {
  /** The tool used to create, maintain and deploy the node. Examples: symbol-bootstrap, manual. */
  deploymentTool: string;
  /** The version of the tool used to create, maintain and deploy the node. */
  deploymentToolVersion: string;
  /** When was the node last upgraded. */
  lastUpdatedDate: string;
}

export interface NodeHealthDTO {
  /** API node service status. */
  apiNode: NodeStatusEnum;
  /** MongoDB service status. */
  db: NodeStatusEnum;
}

export interface NodeHealthInfoDTO {
  status: NodeHealthDTO;
}

export interface NodeInfoDTO {
  /** Version of the application. */
  version: number;
  publicKey: PublicKey;
  networkGenerationHashSeed: Hash256;
  roles: RolesTypeEnum;
  /** Port used for the communication. */
  port: number;
  networkIdentifier: number;
  /** Node friendly name. */
  friendlyName: string;
  /** Node IP address. */
  host: string;
  nodePublicKey?: PublicKey;
}

export interface NodeTimeDTO {
  communicationTimestamps: CommunicationTimestampsDTO;
}

export interface ServerDTO {
  /** catapult-rest component version. */
  restVersion: string;
  /** catapult-sdk component version. */
  sdkVersion: string;
  deployment: DeploymentDTO;
}

export interface ServerInfoDTO {
  serverInfo: ServerDTO;
}

export interface StorageInfoDTO {
  /** Number of blocks stored. */
  numBlocks: number;
  /** Number of transactions stored. */
  numTransactions: number;
  /** Number of accounts created. */
  numAccounts: number;
}

export interface UnlockedAccountDTO {
  unlockedAccount: PublicKey[];
}

/**
 * A transaction could be classified in the following groups:
* Unconfirmed: The transaction reached the P2P network. At this point, it is not guaranteed that the transaction will be included in a block.
* Confirmed: The transaction is included in a block.
* Partial: The transaction requires to be cosigned by other transaction participants in order to be included in a block.
* Failed: The transaction did not pass the network validation, and it was rejected.

 */
export type TransactionGroupEnum = typeof TransactionGroupEnum[keyof typeof TransactionGroupEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionGroupEnum = {
  unconfirmed: 'unconfirmed',
  confirmed: 'confirmed',
  failed: 'failed',
  partial: 'partial',
} as const;

/**
 * List of status errors that can be returned via the status channel after announcing a transaction:
* Success
* Neutral
* Failure
* Failure_Core_Past_Deadline - Validation failed because the deadline passed.
* Failure_Core_Future_Deadline - Validation failed because the deadline is too far in the future.
* Failure_Core_Insufficient_Balance - Validation failed because the account has an insufficient balance.
* Failure_Core_Too_Many_Transactions - Validation failed because there are too many transactions in a block.
* Failure_Core_Nemesis_Account_Signed_After_Nemesis_Block - Validation failed because an entity originated from the nemesis account after the nemesis block.
* Failure_Core_Wrong_Network - Validation failed because the entity has the wrong network specified.
* Failure_Core_Invalid_Address - Validation failed because an address is invalid.
* Failure_Core_Invalid_Version - Validation failed because entity version is invalid.
* Failure_Core_Invalid_Transaction_Fee - Validation failed because a transaction fee is invalid.
* Failure_Core_Block_Harvester_Ineligible - Validation failed because a block was harvested by an ineligible harvester.
* Failure_Core_Zero_Address - Validation failed because an address is zero.
* Failure_Core_Zero_Public_Key - Validation failed because a public key is zero.
* Failure_Core_Nonzero_Internal_Padding - Validation failed because internal padding is nonzero.
* Failure_Core_Address_Collision - Validation failed because an address collision is detected.
* Failure_Core_Importance_Block_Mismatch - Validation failed because the block does not match the schema of an importance block.
* Failure_Core_Unexpected_Block_Type - Validation failed because the block type is unexpected.
* Failure_Core_Block_Explicit_Transactions_Hash_Mismatch - Validation failed because a block did not have the expected transactions hash at a specified height.
* Failure_Core_Invalid_Link_Action - Validation failed because link action is invalid.
* Failure_Core_Link_Already_Exists - Validation failed because main account is already linked to another account.
* Failure_Core_Inconsistent_Unlink_Data - Validation failed because unlink data is not consistent with existing account link.
* Failure_Core_Invalid_Link_Range - Validation failed because link range is invalid.
* Failure_Core_Too_Many_Links - Validation failed because main account has too many links of the specified type.
* Failure_Core_Link_Start_Epoch_Invalid - Validation failed because the start epoch is invalid.
* Failure_Hash_Already_Exists
* Failure_Signature_Not_Verifiable - Validation failed because the verification of the signature failed.
* Failure_AccountLink_Link_Already_Exists - Validation failed because main account is already linked to another account.
* Failure_AccountLink_Inconsistent_Unlink_Data - Validation failed because unlink data is not consistent with existing account link.
* Failure_AccountLink_Unknown_Link - Validation failed because main account is not linked to another account.
* Failure_AccountLink_Remote_Account_Ineligible - Validation failed because link is attempting to convert ineligible account to remote.
* Failure_AccountLink_Remote_Account_Signer_Prohibited - Validation failed because remote is not allowed to sign a transaction.
* Failure_AccountLink_Remote_Account_Participant_Prohibited - Validation failed because remote is not allowed to participate in the transaction.
* Failure_Aggregate_Too_Many_Transactions - Validation failed because aggregate has too many transactions.
* Failure_Aggregate_No_Transactions - Validation failed because aggregate does not have any transactions.
* Failure_Aggregate_Too_Many_Cosignatures - Validation failed because aggregate has too many cosignatures.
* Failure_Aggregate_Redundant_Cosignatures - Validation failed because redundant cosignatures are present.
* Failure_Aggregate_Ineligible_Cosignatories - Validation failed because at least one cosignatory is ineligible.
* Failure_Aggregate_Missing_Cosignatures - Validation failed because at least one required cosignature is missing.
* Failure_Aggregate_Transactions_Hash_Mismatch - Validation failed because the aggregate transactions hash does not match the calculated value.
* Failure_LockHash_Invalid_Mosaic_Id - Validation failed because lock does not allow the specified mosaic.
* Failure_LockHash_Invalid_Mosaic_Amount - Validation failed because lock does not allow the specified amount.
* Failure_LockHash_Hash_Already_Exists - Validation failed because hash is already present in cache.
* Failure_LockHash_Unknown_Hash - Validation failed because hash is not present in cache.
* Failure_LockHash_Inactive_Hash - Validation failed because hash is inactive.
* Failure_LockHash_Invalid_Duration - Validation failed because duration is too long.
* Failure_LockSecret_Invalid_Hash_Algorithm - Validation failed because hash algorithm for lock type secret is invalid.
* Failure_LockSecret_Hash_Already_Exists - Validation failed because hash is already present in cache.
* Failure_LockSecret_Proof_Size_Out_Of_Bounds - Validation failed because proof is too small or too large.
* Failure_LockSecret_Secret_Mismatch - Validation failed because secret does not match proof.
* Failure_LockSecret_Unknown_Composite_Key - Validation failed because composite key is unknown.
* Failure_LockSecret_Inactive_Secret - Validation failed because secret is inactive.
* Failure_LockSecret_Hash_Algorithm_Mismatch - Validation failed because hash algorithm does not match.
* Failure_LockSecret_Invalid_Duration - Validation failed because duration is too long.
* Failure_Metadata_Value_Too_Small - Validation failed because the metadata value is too small.
* Failure_Metadata_Value_Too_Large - Validation failed because the metadata value is too large.
* Failure_Metadata_Value_Size_Delta_Too_Large - Validation failed because the metadata value size delta is larger in magnitude than the value size.
* Failure_Metadata_Value_Size_Delta_Mismatch - Validation failed because the metadata value size delta does not match expected value based on the current state.
* Failure_Metadata_Value_Change_Irreversible - Validation failed because a metadata value change (truncation) is irreversible.
* Failure_Mosaic_Invalid_Duration - Validation failed because the duration has an invalid value.
* Failure_Mosaic_Invalid_Name - Validation failed because the name is invalid.
* Failure_Mosaic_Name_Id_Mismatch - Validation failed because the name and id don't match.
* Failure_Mosaic_Expired - Validation failed because the parent is expired.
* Failure_Mosaic_Owner_Conflict - Validation failed because the parent owner conflicts with the child owner.
* Failure_Mosaic_Id_Mismatch - Validation failed because the id is not the expected id generated from signer and nonce.
* Failure_Mosaic_Parent_Id_Conflict - Validation failed because the existing parent id does not match the supplied parent id.
* Failure_Mosaic_Invalid_Property - Validation failed because a mosaic property is invalid.
* Failure_Mosaic_Invalid_Flags - Validation failed because the mosaic flags are invalid.
* Failure_Mosaic_Invalid_Divisibility - Validation failed because the mosaic divisibility is invalid.
* Failure_Mosaic_Invalid_Supply_Change_Action - Validation failed because the mosaic supply change action is invalid.
* Failure_Mosaic_Invalid_Supply_Change_Amount - Validation failed because the mosaic supply change amount is invalid.
* Failure_Mosaic_Invalid_Id - Validation failed because the mosaic id is invalid.
* Failure_Mosaic_Modification_Disallowed - Validation failed because mosaic modification is not allowed.
* Failure_Mosaic_Modification_No_Changes - Validation failed because mosaic modification would not result in any changes.
* Failure_Mosaic_Supply_Immutable - Validation failed because the mosaic supply is immutable.
* Failure_Mosaic_Supply_Negative - Validation failed because the resulting mosaic supply is negative.
* Failure_Mosaic_Supply_Exceeded - Validation failed because the resulting mosaic supply exceeds the maximum allowed value.
* Failure_Mosaic_Non_Transferable - Validation failed because the mosaic is not transferable.
* Failure_Mosaic_Max_Mosaics_Exceeded - Validation failed because the credit of the mosaic would exceed the maximum of different mosaics an account is allowed to own.
* Failure_Mosaic_Required_Property_Flag_Unset - Validation failed because the mosaic has at least one required property flag unset.
* Failure_Multisig_Account_In_Both_Sets - Validation failed because account is specified to be both added and removed.
* Failure_Multisig_Multiple_Deletes - Validation failed because multiple removals are present.
* Failure_Multisig_Redundant_Modification - Validation failed because a modification is redundant.
* Failure_Multisig_Unknown_Multisig_Account - Validation failed because account is not in multisig cache.
* Failure_Multisig_Not_A_Cosignatory - Validation failed because account to be removed is not present.
* Failure_Multisig_Already_A_Cosignatory - Validation failed because account to be added is already a cosignatory.
* Failure_Multisig_Min_Setting_Out_Of_Range - Validation failed because new minimum settings are out of range.
* Failure_Multisig_Min_Setting_Larger_Than_Num_Cosignatories - Validation failed because min settings are larger than number of cosignatories.
* Failure_Multisig_Invalid_Modification_Action - Validation failed because the modification action is invalid.
* Failure_Multisig_Max_Cosigned_Accounts - Validation failed because the cosignatory already cosigns the maximum number of accounts.
* Failure_Multisig_Max_Cosignatories - Validation failed because the multisig account already has the maximum number of cosignatories.
* Failure_Multisig_Loop - Validation failed because a multisig loop is created.
* Failure_Multisig_Max_Multisig_Depth - Validation failed because the max multisig depth is exceeded.
* Failure_Multisig_Operation_Prohibited_By_Account - Validation failed because an operation is not permitted by a multisig account.
* Failure_Namespace_Invalid_Duration - Validation failed because the duration has an invalid value.
* Failure_Namespace_Invalid_Name - Validation failed because the name is invalid.
* Failure_Namespace_Name_Id_Mismatch - Validation failed because the name and id don't match.
* Failure_Namespace_Expired - Validation failed because the parent is expired.
* Failure_Namespace_Owner_Conflict - Validation failed because the parent owner conflicts with the child owner.
* Failure_Namespace_Id_Mismatch - Validation failed because the id is not the expected id generated from signer and nonce.
* Failure_Namespace_Invalid_Registration_Type - Validation failed because the namespace registration type is invalid.
* Failure_Namespace_Root_Name_Reserved - Validation failed because the root namespace has a reserved name.
* Failure_Namespace_Too_Deep - Validation failed because the resulting namespace would exceed the maximum allowed namespace depth.
* Failure_Namespace_Unknown_Parent - Validation failed because the namespace parent is unknown.
* Failure_Namespace_Already_Exists - Validation failed because the namespace already exists.
* Failure_Namespace_Already_Active - Validation failed because the namespace is already active.
* Failure_Namespace_Eternal_After_Nemesis_Block - Validation failed because an eternal namespace was received after the nemesis block.
* Failure_Namespace_Max_Children_Exceeded - Validation failed because the maximum number of children for a root namespace was exceeded.
* Failure_Namespace_Alias_Invalid_Action - Validation failed because alias action is invalid.
* Failure_Namespace_Unknown - Validation failed because namespace does not exist.
* Failure_Namespace_Alias_Already_Exists - Validation failed because namespace is already linked to an alias.
* Failure_Namespace_Unknown_Alias - Validation failed because namespace is not linked to an alias.
* Failure_Namespace_Alias_Inconsistent_Unlink_Type - Validation failed because unlink type is not consistent with existing alias.
* Failure_Namespace_Alias_Inconsistent_Unlink_Data - Validation failed because unlink data is not consistent with existing alias.
* Failure_Namespace_Alias_Invalid_Address - Validation failed because aliased address is invalid.
* Failure_RestrictionAccount_Invalid_Restriction_Flags - Validation failed because the account restriction flags are invalid.
* Failure_RestrictionAccount_Invalid_Modification_Action - Validation failed because a modification action is invalid.
* Failure_RestrictionAccount_Invalid_Modification_Address - Validation failed because a modification address is invalid.
* Failure_RestrictionAccount_Modification_Operation_Type_Incompatible - Validation failed because the operation type is incompatible. *Note*: This indicates that the existing restrictions have a different operation type than that specified in the notification.
* Failure_RestrictionAccount_Redundant_Modification - Validation failed because a modification is redundant.
* Failure_RestrictionAccount_Invalid_Modification - Validation failed because a value is not in the container.
* Failure_RestrictionAccount_Modification_Count_Exceeded - Validation failed because the transaction has too many modifications.
* Failure_RestrictionAccount_No_Modifications - Validation failed because the transaction has no modifications.
* Failure_RestrictionAccount_Values_Count_Exceeded - Validation failed because the resulting account restriction has too many values.
* Failure_RestrictionAccount_Invalid_Value - Validation failed because the account restriction value is invalid.
* Failure_RestrictionAccount_Address_Interaction_Prohibited - Validation failed because the addresses involved in the transaction are not allowed to interact.
* Failure_RestrictionAccount_Mosaic_Transfer_Prohibited - Validation failed because the mosaic transfer is prohibited by the recipient.
* Failure_RestrictionAccount_Operation_Type_Prohibited - Validation failed because the operation type is not allowed to be initiated by the signer.
* Failure_RestrictionMosaic_Invalid_Restriction_Type - Validation failed because the mosaic restriction type is invalid.
* Failure_RestrictionMosaic_Previous_Value_Mismatch - Validation failed because specified previous value does not match current value.
* Failure_RestrictionMosaic_Previous_Value_Must_Be_Zero - Validation failed because specified previous value is nonzero.
* Failure_RestrictionMosaic_Max_Restrictions_Exceeded - Validation failed because the maximum number of restrictions would be exceeded.
* Failure_RestrictionMosaic_Cannot_Delete_Nonexistent_Restriction - Validation failed because nonexistent restriction cannot be deleted.
* Failure_RestrictionMosaic_Unknown_Global_Restriction - Validation failed because required global restriction does not exist.
* Failure_RestrictionMosaic_Invalid_Global_Restriction - Validation failed because mosaic has invalid global restriction.
* Failure_RestrictionMosaic_Account_Unauthorized - Validation failed because account lacks proper permissions to move mosaic.
* Failure_Transfer_Message_Too_Large - Validation failed because the message is too large.
* Failure_Transfer_Out_Of_Order_Mosaics - Validation failed because mosaics are out of order.
* Failure_Chain_Unlinked - Validation failed because a block was received that did not link with the existing chain.
* Failure_Chain_Block_Not_Hit - Validation failed because a block was received that is not a hit.
* Failure_Chain_Block_Inconsistent_State_Hash - Validation failed because a block was received that has an inconsistent state hash.
* Failure_Chain_Block_Inconsistent_Receipts_Hash - Validation failed because a block was received that has an inconsistent receipts hash.
* Failure_Chain_Block_Invalid_Vrf_Proof - Validation failed because the Vrf proof is invalid.
* Failure_Chain_Block_Unknown_Signer - Validation failed because the block signer is unknown.
* Failure_Chain_Unconfirmed_Cache_Too_Full - Validation failed because the unconfirmed cache is too full.
* Failure_Consumer_Empty_Input - Validation failed because the consumer input is empty.
* Failure_Consumer_Block_Transactions_Hash_Mismatch - Validation failed because the block transactions hash does not match the calculated value.
* Neutral_Consumer_Hash_In_Recency_Cache - Validation failed because an entity hash is present in the recency cache.
* Failure_Consumer_Remote_Chain_Too_Many_Blocks - Validation failed because the chain part has too many blocks.
* Failure_Consumer_Remote_Chain_Improper_Link - Validation failed because the chain is internally improperly linked.
* Failure_Consumer_Remote_Chain_Duplicate_Transactions - Validation failed because the chain part contains duplicate transactions.
* Failure_Consumer_Remote_Chain_Unlinked - Validation failed because the chain part does not link to the current chain.
* Failure_Consumer_Remote_Chain_Difficulties_Mismatch - Validation failed because the remote chain difficulties do not match the calculated difficulties.
* Failure_Consumer_Remote_Chain_Score_Not_Better - Validation failed because the remote chain score is not better.
* Failure_Consumer_Remote_Chain_Too_Far_Behind - Validation failed because the remote chain is too far behind.
* Failure_Consumer_Remote_Chain_Too_Far_In_Future - Validation failed because the remote chain timestamp is too far in the future.
* Failure_Consumer_Batch_Signature_Not_Verifiable - Validation failed because the verification of the signature failed during a batch operation.
* Failure_Consumer_Remote_Chain_Improper_Importance_Link - Validation failed because the remote chain has an improper importance link.
* Failure_Extension_Partial_Transaction_Cache_Prune - Validation failed because the partial transaction was pruned from the temporal cache.
* Failure_Extension_Partial_Transaction_Dependency_Removed - Validation failed because the partial transaction was pruned from the temporal cache due to its dependency being removed.
* Failure_Extension_Read_Rate_Limit_Exceeded - Validation failed because socket read rate limit was exceeded.

 */
export type TransactionStatusEnum = typeof TransactionStatusEnum[keyof typeof TransactionStatusEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionStatusEnum = {
  Success: 'Success',
  Neutral: 'Neutral',
  Failure: 'Failure',
  Failure_Core_Past_Deadline: 'Failure_Core_Past_Deadline',
  Failure_Core_Future_Deadline: 'Failure_Core_Future_Deadline',
  Failure_Core_Insufficient_Balance: 'Failure_Core_Insufficient_Balance',
  Failure_Core_Too_Many_Transactions: 'Failure_Core_Too_Many_Transactions',
  Failure_Core_Nemesis_Account_Signed_After_Nemesis_Block: 'Failure_Core_Nemesis_Account_Signed_After_Nemesis_Block',
  Failure_Core_Wrong_Network: 'Failure_Core_Wrong_Network',
  Failure_Core_Invalid_Address: 'Failure_Core_Invalid_Address',
  Failure_Core_Invalid_Version: 'Failure_Core_Invalid_Version',
  Failure_Core_Invalid_Transaction_Fee: 'Failure_Core_Invalid_Transaction_Fee',
  Failure_Core_Block_Harvester_Ineligible: 'Failure_Core_Block_Harvester_Ineligible',
  Failure_Core_Zero_Address: 'Failure_Core_Zero_Address',
  Failure_Core_Zero_Public_Key: 'Failure_Core_Zero_Public_Key',
  Failure_Core_Nonzero_Internal_Padding: 'Failure_Core_Nonzero_Internal_Padding',
  Failure_Core_Address_Collision: 'Failure_Core_Address_Collision',
  Failure_Core_Importance_Block_Mismatch: 'Failure_Core_Importance_Block_Mismatch',
  Failure_Core_Unexpected_Block_Type: 'Failure_Core_Unexpected_Block_Type',
  Failure_Core_Block_Explicit_Transactions_Hash_Mismatch: 'Failure_Core_Block_Explicit_Transactions_Hash_Mismatch',
  Failure_Core_Invalid_Link_Action: 'Failure_Core_Invalid_Link_Action',
  Failure_Core_Link_Already_Exists: 'Failure_Core_Link_Already_Exists',
  Failure_Core_Inconsistent_Unlink_Data: 'Failure_Core_Inconsistent_Unlink_Data',
  Failure_Core_Invalid_Link_Range: 'Failure_Core_Invalid_Link_Range',
  Failure_Core_Too_Many_Links: 'Failure_Core_Too_Many_Links',
  Failure_Core_Link_Start_Epoch_Invalid: 'Failure_Core_Link_Start_Epoch_Invalid',
  Failure_Hash_Already_Exists: 'Failure_Hash_Already_Exists',
  Failure_Signature_Not_Verifiable: 'Failure_Signature_Not_Verifiable',
  Failure_AccountLink_Link_Already_Exists: 'Failure_AccountLink_Link_Already_Exists',
  Failure_AccountLink_Inconsistent_Unlink_Data: 'Failure_AccountLink_Inconsistent_Unlink_Data',
  Failure_AccountLink_Unknown_Link: 'Failure_AccountLink_Unknown_Link',
  Failure_AccountLink_Remote_Account_Ineligible: 'Failure_AccountLink_Remote_Account_Ineligible',
  Failure_AccountLink_Remote_Account_Signer_Prohibited: 'Failure_AccountLink_Remote_Account_Signer_Prohibited',
  Failure_AccountLink_Remote_Account_Participant_Prohibited: 'Failure_AccountLink_Remote_Account_Participant_Prohibited',
  Failure_Aggregate_Too_Many_Transactions: 'Failure_Aggregate_Too_Many_Transactions',
  Failure_Aggregate_No_Transactions: 'Failure_Aggregate_No_Transactions',
  Failure_Aggregate_Too_Many_Cosignatures: 'Failure_Aggregate_Too_Many_Cosignatures',
  Failure_Aggregate_Redundant_Cosignatures: 'Failure_Aggregate_Redundant_Cosignatures',
  Failure_Aggregate_Ineligible_Cosignatories: 'Failure_Aggregate_Ineligible_Cosignatories',
  Failure_Aggregate_Missing_Cosignatures: 'Failure_Aggregate_Missing_Cosignatures',
  Failure_Aggregate_Transactions_Hash_Mismatch: 'Failure_Aggregate_Transactions_Hash_Mismatch',
  Failure_LockHash_Invalid_Mosaic_Id: 'Failure_LockHash_Invalid_Mosaic_Id',
  Failure_LockHash_Invalid_Mosaic_Amount: 'Failure_LockHash_Invalid_Mosaic_Amount',
  Failure_LockHash_Hash_Already_Exists: 'Failure_LockHash_Hash_Already_Exists',
  Failure_LockHash_Unknown_Hash: 'Failure_LockHash_Unknown_Hash',
  Failure_LockHash_Inactive_Hash: 'Failure_LockHash_Inactive_Hash',
  Failure_LockHash_Invalid_Duration: 'Failure_LockHash_Invalid_Duration',
  Failure_LockSecret_Invalid_Hash_Algorithm: 'Failure_LockSecret_Invalid_Hash_Algorithm',
  Failure_LockSecret_Hash_Already_Exists: 'Failure_LockSecret_Hash_Already_Exists',
  Failure_LockSecret_Proof_Size_Out_Of_Bounds: 'Failure_LockSecret_Proof_Size_Out_Of_Bounds',
  Failure_LockSecret_Secret_Mismatch: 'Failure_LockSecret_Secret_Mismatch',
  Failure_LockSecret_Unknown_Composite_Key: 'Failure_LockSecret_Unknown_Composite_Key',
  Failure_LockSecret_Inactive_Secret: 'Failure_LockSecret_Inactive_Secret',
  Failure_LockSecret_Hash_Algorithm_Mismatch: 'Failure_LockSecret_Hash_Algorithm_Mismatch',
  Failure_LockSecret_Invalid_Duration: 'Failure_LockSecret_Invalid_Duration',
  Failure_Metadata_Value_Too_Small: 'Failure_Metadata_Value_Too_Small',
  Failure_Metadata_Value_Too_Large: 'Failure_Metadata_Value_Too_Large',
  Failure_Metadata_Value_Size_Delta_Too_Large: 'Failure_Metadata_Value_Size_Delta_Too_Large',
  Failure_Metadata_Value_Size_Delta_Mismatch: 'Failure_Metadata_Value_Size_Delta_Mismatch',
  Failure_Metadata_Value_Change_Irreversible: 'Failure_Metadata_Value_Change_Irreversible',
  Failure_Mosaic_Invalid_Duration: 'Failure_Mosaic_Invalid_Duration',
  Failure_Mosaic_Invalid_Name: 'Failure_Mosaic_Invalid_Name',
  Failure_Mosaic_Name_Id_Mismatch: 'Failure_Mosaic_Name_Id_Mismatch',
  Failure_Mosaic_Expired: 'Failure_Mosaic_Expired',
  Failure_Mosaic_Owner_Conflict: 'Failure_Mosaic_Owner_Conflict',
  Failure_Mosaic_Id_Mismatch: 'Failure_Mosaic_Id_Mismatch',
  Failure_Mosaic_Parent_Id_Conflict: 'Failure_Mosaic_Parent_Id_Conflict',
  Failure_Mosaic_Invalid_Property: 'Failure_Mosaic_Invalid_Property',
  Failure_Mosaic_Invalid_Flags: 'Failure_Mosaic_Invalid_Flags',
  Failure_Mosaic_Invalid_Divisibility: 'Failure_Mosaic_Invalid_Divisibility',
  Failure_Mosaic_Invalid_Supply_Change_Action: 'Failure_Mosaic_Invalid_Supply_Change_Action',
  Failure_Mosaic_Invalid_Supply_Change_Amount: 'Failure_Mosaic_Invalid_Supply_Change_Amount',
  Failure_Mosaic_Invalid_Id: 'Failure_Mosaic_Invalid_Id',
  Failure_Mosaic_Modification_Disallowed: 'Failure_Mosaic_Modification_Disallowed',
  Failure_Mosaic_Modification_No_Changes: 'Failure_Mosaic_Modification_No_Changes',
  Failure_Mosaic_Supply_Immutable: 'Failure_Mosaic_Supply_Immutable',
  Failure_Mosaic_Supply_Negative: 'Failure_Mosaic_Supply_Negative',
  Failure_Mosaic_Supply_Exceeded: 'Failure_Mosaic_Supply_Exceeded',
  Failure_Mosaic_Non_Transferable: 'Failure_Mosaic_Non_Transferable',
  Failure_Mosaic_Max_Mosaics_Exceeded: 'Failure_Mosaic_Max_Mosaics_Exceeded',
  Failure_Mosaic_Required_Property_Flag_Unset: 'Failure_Mosaic_Required_Property_Flag_Unset',
  Failure_Multisig_Account_In_Both_Sets: 'Failure_Multisig_Account_In_Both_Sets',
  Failure_Multisig_Multiple_Deletes: 'Failure_Multisig_Multiple_Deletes',
  Failure_Multisig_Redundant_Modification: 'Failure_Multisig_Redundant_Modification',
  Failure_Multisig_Unknown_Multisig_Account: 'Failure_Multisig_Unknown_Multisig_Account',
  Failure_Multisig_Not_A_Cosignatory: 'Failure_Multisig_Not_A_Cosignatory',
  Failure_Multisig_Already_A_Cosignatory: 'Failure_Multisig_Already_A_Cosignatory',
  Failure_Multisig_Min_Setting_Out_Of_Range: 'Failure_Multisig_Min_Setting_Out_Of_Range',
  Failure_Multisig_Min_Setting_Larger_Than_Num_Cosignatories: 'Failure_Multisig_Min_Setting_Larger_Than_Num_Cosignatories',
  Failure_Multisig_Invalid_Modification_Action: 'Failure_Multisig_Invalid_Modification_Action',
  Failure_Multisig_Max_Cosigned_Accounts: 'Failure_Multisig_Max_Cosigned_Accounts',
  Failure_Multisig_Max_Cosignatories: 'Failure_Multisig_Max_Cosignatories',
  Failure_Multisig_Loop: 'Failure_Multisig_Loop',
  Failure_Multisig_Max_Multisig_Depth: 'Failure_Multisig_Max_Multisig_Depth',
  Failure_Multisig_Operation_Prohibited_By_Account: 'Failure_Multisig_Operation_Prohibited_By_Account',
  Failure_Namespace_Invalid_Duration: 'Failure_Namespace_Invalid_Duration',
  Failure_Namespace_Invalid_Name: 'Failure_Namespace_Invalid_Name',
  Failure_Namespace_Name_Id_Mismatch: 'Failure_Namespace_Name_Id_Mismatch',
  Failure_Namespace_Expired: 'Failure_Namespace_Expired',
  Failure_Namespace_Owner_Conflict: 'Failure_Namespace_Owner_Conflict',
  Failure_Namespace_Id_Mismatch: 'Failure_Namespace_Id_Mismatch',
  Failure_Namespace_Invalid_Registration_Type: 'Failure_Namespace_Invalid_Registration_Type',
  Failure_Namespace_Root_Name_Reserved: 'Failure_Namespace_Root_Name_Reserved',
  Failure_Namespace_Too_Deep: 'Failure_Namespace_Too_Deep',
  Failure_Namespace_Unknown_Parent: 'Failure_Namespace_Unknown_Parent',
  Failure_Namespace_Already_Exists: 'Failure_Namespace_Already_Exists',
  Failure_Namespace_Already_Active: 'Failure_Namespace_Already_Active',
  Failure_Namespace_Eternal_After_Nemesis_Block: 'Failure_Namespace_Eternal_After_Nemesis_Block',
  Failure_Namespace_Max_Children_Exceeded: 'Failure_Namespace_Max_Children_Exceeded',
  Failure_Namespace_Alias_Invalid_Action: 'Failure_Namespace_Alias_Invalid_Action',
  Failure_Namespace_Unknown: 'Failure_Namespace_Unknown',
  Failure_Namespace_Alias_Already_Exists: 'Failure_Namespace_Alias_Already_Exists',
  Failure_Namespace_Unknown_Alias: 'Failure_Namespace_Unknown_Alias',
  Failure_Namespace_Alias_Inconsistent_Unlink_Type: 'Failure_Namespace_Alias_Inconsistent_Unlink_Type',
  Failure_Namespace_Alias_Inconsistent_Unlink_Data: 'Failure_Namespace_Alias_Inconsistent_Unlink_Data',
  Failure_Namespace_Alias_Invalid_Address: 'Failure_Namespace_Alias_Invalid_Address',
  Failure_RestrictionAccount_Invalid_Restriction_Flags: 'Failure_RestrictionAccount_Invalid_Restriction_Flags',
  Failure_RestrictionAccount_Invalid_Modification_Action: 'Failure_RestrictionAccount_Invalid_Modification_Action',
  Failure_RestrictionAccount_Invalid_Modification_Address: 'Failure_RestrictionAccount_Invalid_Modification_Address',
  Failure_RestrictionAccount_Modification_Operation_Type_Incompatible: 'Failure_RestrictionAccount_Modification_Operation_Type_Incompatible',
  Failure_RestrictionAccount_Redundant_Modification: 'Failure_RestrictionAccount_Redundant_Modification',
  Failure_RestrictionAccount_Invalid_Modification: 'Failure_RestrictionAccount_Invalid_Modification',
  Failure_RestrictionAccount_Modification_Count_Exceeded: 'Failure_RestrictionAccount_Modification_Count_Exceeded',
  Failure_RestrictionAccount_No_Modifications: 'Failure_RestrictionAccount_No_Modifications',
  Failure_RestrictionAccount_Values_Count_Exceeded: 'Failure_RestrictionAccount_Values_Count_Exceeded',
  Failure_RestrictionAccount_Invalid_Value: 'Failure_RestrictionAccount_Invalid_Value',
  Failure_RestrictionAccount_Address_Interaction_Prohibited: 'Failure_RestrictionAccount_Address_Interaction_Prohibited',
  Failure_RestrictionAccount_Mosaic_Transfer_Prohibited: 'Failure_RestrictionAccount_Mosaic_Transfer_Prohibited',
  Failure_RestrictionAccount_Operation_Type_Prohibited: 'Failure_RestrictionAccount_Operation_Type_Prohibited',
  Failure_RestrictionMosaic_Invalid_Restriction_Type: 'Failure_RestrictionMosaic_Invalid_Restriction_Type',
  Failure_RestrictionMosaic_Previous_Value_Mismatch: 'Failure_RestrictionMosaic_Previous_Value_Mismatch',
  Failure_RestrictionMosaic_Previous_Value_Must_Be_Zero: 'Failure_RestrictionMosaic_Previous_Value_Must_Be_Zero',
  Failure_RestrictionMosaic_Max_Restrictions_Exceeded: 'Failure_RestrictionMosaic_Max_Restrictions_Exceeded',
  Failure_RestrictionMosaic_Cannot_Delete_Nonexistent_Restriction: 'Failure_RestrictionMosaic_Cannot_Delete_Nonexistent_Restriction',
  Failure_RestrictionMosaic_Unknown_Global_Restriction: 'Failure_RestrictionMosaic_Unknown_Global_Restriction',
  Failure_RestrictionMosaic_Invalid_Global_Restriction: 'Failure_RestrictionMosaic_Invalid_Global_Restriction',
  Failure_RestrictionMosaic_Account_Unauthorized: 'Failure_RestrictionMosaic_Account_Unauthorized',
  Failure_Transfer_Message_Too_Large: 'Failure_Transfer_Message_Too_Large',
  Failure_Transfer_Out_Of_Order_Mosaics: 'Failure_Transfer_Out_Of_Order_Mosaics',
  Failure_Chain_Unlinked: 'Failure_Chain_Unlinked',
  Failure_Chain_Block_Not_Hit: 'Failure_Chain_Block_Not_Hit',
  Failure_Chain_Block_Inconsistent_State_Hash: 'Failure_Chain_Block_Inconsistent_State_Hash',
  Failure_Chain_Block_Inconsistent_Receipts_Hash: 'Failure_Chain_Block_Inconsistent_Receipts_Hash',
  Failure_Chain_Block_Invalid_Vrf_Proof: 'Failure_Chain_Block_Invalid_Vrf_Proof',
  Failure_Chain_Block_Unknown_Signer: 'Failure_Chain_Block_Unknown_Signer',
  Failure_Chain_Unconfirmed_Cache_Too_Full: 'Failure_Chain_Unconfirmed_Cache_Too_Full',
  Failure_Consumer_Empty_Input: 'Failure_Consumer_Empty_Input',
  Failure_Consumer_Block_Transactions_Hash_Mismatch: 'Failure_Consumer_Block_Transactions_Hash_Mismatch',
  Neutral_Consumer_Hash_In_Recency_Cache: 'Neutral_Consumer_Hash_In_Recency_Cache',
  Failure_Consumer_Remote_Chain_Too_Many_Blocks: 'Failure_Consumer_Remote_Chain_Too_Many_Blocks',
  Failure_Consumer_Remote_Chain_Improper_Link: 'Failure_Consumer_Remote_Chain_Improper_Link',
  Failure_Consumer_Remote_Chain_Duplicate_Transactions: 'Failure_Consumer_Remote_Chain_Duplicate_Transactions',
  Failure_Consumer_Remote_Chain_Unlinked: 'Failure_Consumer_Remote_Chain_Unlinked',
  Failure_Consumer_Remote_Chain_Difficulties_Mismatch: 'Failure_Consumer_Remote_Chain_Difficulties_Mismatch',
  Failure_Consumer_Remote_Chain_Score_Not_Better: 'Failure_Consumer_Remote_Chain_Score_Not_Better',
  Failure_Consumer_Remote_Chain_Too_Far_Behind: 'Failure_Consumer_Remote_Chain_Too_Far_Behind',
  Failure_Consumer_Remote_Chain_Too_Far_In_Future: 'Failure_Consumer_Remote_Chain_Too_Far_In_Future',
  Failure_Consumer_Batch_Signature_Not_Verifiable: 'Failure_Consumer_Batch_Signature_Not_Verifiable',
  Failure_Consumer_Remote_Chain_Improper_Importance_Link: 'Failure_Consumer_Remote_Chain_Improper_Importance_Link',
  Failure_Extension_Partial_Transaction_Cache_Prune: 'Failure_Extension_Partial_Transaction_Cache_Prune',
  Failure_Extension_Partial_Transaction_Dependency_Removed: 'Failure_Extension_Partial_Transaction_Dependency_Removed',
  Failure_Extension_Read_Rate_Limit_Exceeded: 'Failure_Extension_Read_Rate_Limit_Exceeded',
} as const;

/**
 * Type of transaction:
* 0x414C (16716 decimal) - AccountKeyLinkTransaction.
* 0x4243 (16963 decimal) - VrfKeyLinkTransaction.
* 0x4143 (16707 decimal) - VotingKeyLinkTransaction.
* 0x424C (16972 decimal) - NodeKeyLinkTransaction.
* 0x4141 (16705 decimal) - AggregateCompleteTransaction.
* 0x4241 (16961 decimal) - AggregateBondedTransaction.
* 0x414D (16717 decimal) - MosaicDefinitionTransaction.
* 0x424D (16973 decimal) - MosaicSupplyChangeTransaction.
* 0x434D (17229 decimal) - MosaicSupplyRevocationTransaction.
* 0x414E (16718 decimal) - NamespaceRegistrationTransaction.
* 0x424E (16974 decimal) - AddressAliasTransaction.
* 0x434E (17230 decimal) - MosaicAliasTransaction.
* 0x4144 (16708 decimal) - AccountMetadataTransaction.
* 0x4244 (16964 decimal) - MosaicMetadataTransaction.
* 0x4344 (17220 decimal) - NamespaceMetadataTransaction.
* 0x4155 (16725 decimal) - MultisigAccountModificationTransaction.
* 0x4148 (16712 decimal) - HashLockTransaction.
* 0x4152 (16722 decimal) - SecretLockTransaction.
* 0x4252 (16978 decimal) - SecretProofTransaction.
* 0x4150 (16720 decimal) - AccountAddressRestrictionTransaction.
* 0x4250 (16976 decimal) - AccountMosaicRestrictionTransaction.
* 0x4350 (17232 decimal) - AccountOperationRestrictionTransaction.
* 0x4151 (16721 decimal) - MosaicGlobalRestrictionTransaction.
* 0x4251 (16977 decimal) - MosaicAddressRestrictionTransaction.
* 0x4154 (16724 decimal) - TransferTransaction.

 */
export type TransactionTypeEnum = typeof TransactionTypeEnum[keyof typeof TransactionTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TransactionTypeEnum = {
  NUMBER_16716: 16716,
  NUMBER_16963: 16963,
  NUMBER_16707: 16707,
  NUMBER_16972: 16972,
  NUMBER_16705: 16705,
  NUMBER_16961: 16961,
  NUMBER_16717: 16717,
  NUMBER_16973: 16973,
  NUMBER_17229: 17229,
  NUMBER_16718: 16718,
  NUMBER_16974: 16974,
  NUMBER_17230: 17230,
  NUMBER_16708: 16708,
  NUMBER_16964: 16964,
  NUMBER_17220: 17220,
  NUMBER_16725: 16725,
  NUMBER_16712: 16712,
  NUMBER_16722: 16722,
  NUMBER_16978: 16978,
  NUMBER_16720: 16720,
  NUMBER_16976: 16976,
  NUMBER_17232: 17232,
  NUMBER_16721: 16721,
  NUMBER_16977: 16977,
  NUMBER_16724: 16724,
} as const;

export interface AnnounceTransactionInfoDTO {
  message: string;
}

export interface EmbeddedTransactionBodyDTO {
  /** Array of transactions initiated by different accounts. */
  transactions: EmbeddedTransactionInfoDTO[];
}

export type EmbeddedTransactionDTO = EntityDTO;

export type EmbeddedTransactionInfoDTOTransaction = EmbeddedAccountKeyLinkTransactionDTO | EmbeddedNodeKeyLinkTransactionDTO | EmbeddedVrfKeyLinkTransactionDTO | EmbeddedVotingKeyLinkTransactionDTO | EmbeddedHashLockTransactionDTO | EmbeddedSecretLockTransactionDTO | EmbeddedSecretProofTransactionDTO | EmbeddedAccountMetadataTransactionDTO | EmbeddedMosaicMetadataTransactionDTO | EmbeddedNamespaceMetadataTransactionDTO | EmbeddedMosaicDefinitionTransactionDTO | EmbeddedMosaicSupplyChangeTransactionDTO | EmbeddedMosaicSupplyRevocationTransactionDTO | EmbeddedNamespaceRegistrationTransactionDTO | EmbeddedAddressAliasTransactionDTO | EmbeddedMosaicAliasTransactionDTO | EmbeddedMultisigAccountModificationTransactionDTO | EmbeddedAccountAddressRestrictionTransactionDTO | EmbeddedAccountMosaicRestrictionTransactionDTO | EmbeddedAccountOperationRestrictionTransactionDTO | EmbeddedMosaicGlobalRestrictionTransactionDTO | EmbeddedMosaicAddressRestrictionTransactionDTO | EmbeddedTransferTransactionDTO;

export interface EmbeddedTransactionInfoDTO {
  /** Internal resource identifier. */
  id: string;
  meta: EmbeddedTransactionMetaDTO;
  transaction: EmbeddedTransactionInfoDTOTransaction;
}

export interface EmbeddedTransactionMetaDTO {
  height: Height;
  aggregateHash: Hash256;
  /** Identifier of the aggregate transaction. */
  aggregateId: string;
  /** Transaction index within the aggregate. */
  index: number;
  timestamp?: Timestamp;
  feeMultiplier?: BlockFeeMultiplier;
}

export interface TransactionPage {
  /** Array of transactions. */
  data: TransactionInfoDTO[];
  pagination: Pagination;
}

export interface TransactionBodyDTO {
  maxFee: Amount;
  deadline: BlockDuration;
}

export type TransactionDTO = SizePrefixedEntityDTO & VerifiableEntityDTO & EntityDTO & TransactionBodyDTO;

export type TransactionInfoDTOMeta = TransactionMetaDTO | EmbeddedTransactionMetaDTO;

export type TransactionInfoDTOTransaction = AccountKeyLinkTransactionDTO | EmbeddedAccountKeyLinkTransactionDTO | NodeKeyLinkTransactionDTO | EmbeddedNodeKeyLinkTransactionDTO | VrfKeyLinkTransactionDTO | EmbeddedVrfKeyLinkTransactionDTO | VotingKeyLinkTransactionDTO | EmbeddedVotingKeyLinkTransactionDTO | AggregateTransactionDTO | AggregateTransactionExtendedDTO | HashLockTransactionDTO | EmbeddedHashLockTransactionDTO | SecretLockTransactionDTO | EmbeddedSecretLockTransactionDTO | SecretProofTransactionDTO | EmbeddedSecretProofTransactionDTO | AccountMetadataTransactionDTO | EmbeddedAccountMetadataTransactionDTO | MosaicMetadataTransactionDTO | EmbeddedMosaicMetadataTransactionDTO | NamespaceMetadataTransactionDTO | EmbeddedNamespaceMetadataTransactionDTO | MosaicDefinitionTransactionDTO | EmbeddedMosaicDefinitionTransactionDTO | MosaicSupplyChangeTransactionDTO | EmbeddedMosaicSupplyChangeTransactionDTO | MosaicSupplyRevocationTransactionDTO | EmbeddedMosaicSupplyRevocationTransactionDTO | NamespaceRegistrationTransactionDTO | EmbeddedNamespaceRegistrationTransactionDTO | AddressAliasTransactionDTO | EmbeddedAddressAliasTransactionDTO | MosaicAliasTransactionDTO | EmbeddedMosaicAliasTransactionDTO | MultisigAccountModificationTransactionDTO | EmbeddedMultisigAccountModificationTransactionDTO | AccountAddressRestrictionTransactionDTO | EmbeddedAccountAddressRestrictionTransactionDTO | AccountMosaicRestrictionTransactionDTO | EmbeddedAccountMosaicRestrictionTransactionDTO | AccountOperationRestrictionTransactionDTO | EmbeddedAccountOperationRestrictionTransactionDTO | MosaicGlobalRestrictionTransactionDTO | EmbeddedMosaicGlobalRestrictionTransactionDTO | MosaicAddressRestrictionTransactionDTO | EmbeddedMosaicAddressRestrictionTransactionDTO | TransferTransactionDTO | EmbeddedTransferTransactionDTO;

export interface TransactionInfoDTO {
  /** Internal resource identifier. */
  id: string;
  meta: TransactionInfoDTOMeta;
  transaction: TransactionInfoDTOTransaction;
}

export interface TransactionMetaDTO {
  height: Height;
  hash: Hash256;
  merkleComponentHash: Hash256;
  /** Transaction index within the block. */
  index: number;
  timestamp?: Timestamp;
  feeMultiplier?: BlockFeeMultiplier;
}

export interface TransactionStatusDTO {
  group: TransactionGroupEnum;
  code?: TransactionStatusEnum;
  hash: Hash256;
  deadline: BlockDuration;
  height?: Height;
}

export interface AccountKeyLinkNetworkPropertiesDTO {
  /** to trigger plugin load */
  dummy?: string;
}

export interface AccountKeyLinkTransactionBodyDTO {
  linkedPublicKey: PublicKey;
  linkAction: LinkActionEnum;
}

/**
 * Transaction to delegate the account importance score to a proxy account.
Required for all accounts willing to activate delegated harvesting.

 */
export type AccountKeyLinkTransactionDTO = TransactionDTO & AccountKeyLinkTransactionBodyDTO;

export type EmbeddedAccountKeyLinkTransactionDTO = EmbeddedTransactionDTO & AccountKeyLinkTransactionBodyDTO;

export interface NodeKeyLinkNetworkPropertiesDTO {
  /** to trigger plugin load */
  dummy?: string;
}

export interface NodeKeyLinkTransactionBodyDTO {
  linkedPublicKey: PublicKey;
  linkAction: LinkActionEnum;
}

/**
 * Transaction to link a public key to an account.
TLS uses the linked public key to create sessions.
Required for node operators. 

 */
export type NodeKeyLinkTransactionDTO = TransactionDTO & NodeKeyLinkTransactionBodyDTO;

export type EmbeddedNodeKeyLinkTransactionDTO = EmbeddedTransactionDTO & NodeKeyLinkTransactionBodyDTO;

export interface AggregateNetworkPropertiesDTO {
  /** Maximum number of transactions per aggregate. */
  maxTransactionsPerAggregate?: string;
  /** Maximum number of cosignatures per aggregate. */
  maxCosignaturesPerAggregate?: string;
  /** Set to true if cosignatures must exactly match component signers. Set to false if cosignatures should be validated externally. */
  enableStrictCosignatureCheck?: boolean;
  /** Set to true if bonded aggregates should be allowed. Set to false if bonded aggregates should be rejected. */
  enableBondedAggregateSupport?: boolean;
  /** Maximum lifetime a bonded transaction can have before it expires. */
  maxBondedTransactionLifetime?: string;
}

export interface AggregateTransactionBodyDTO {
  transactionsHash: Hash256;
  /** Array of transaction cosignatures. */
  cosignatures: CosignatureDTO[];
}

export type AggregateTransactionBodyExtendedDTO = AggregateTransactionBodyDTO & EmbeddedTransactionBodyDTO;

/**
 * Transaction to combine multiple transactions together.
 */
export type AggregateTransactionDTO = TransactionDTO & AggregateTransactionBodyDTO;

/**
 * Transaction to combine multiple transactions together.
 */
export type AggregateTransactionExtendedDTO = TransactionDTO & AggregateTransactionBodyExtendedDTO;

export type CosignatureDTOAllOf = {
  version: CosignatureVersion;
  signerPublicKey: PublicKey;
};

export type CosignatureDTO = VerifiableEntityDTO & CosignatureDTOAllOf;

export interface VrfKeyLinkNetworkPropertiesDTO {
  /** to trigger plugin load */
  dummy?: string;
}

export interface VrfKeyLinkTransactionBodyDTO {
  linkedPublicKey: PublicKey;
  linkAction: LinkActionEnum;
}

/**
 * Transaction to link an account with a VRF public key.
The key is used to randomize block production and leader/participant selection.
Required for all harvesting eligible accounts.

 */
export type VrfKeyLinkTransactionDTO = TransactionDTO & VrfKeyLinkTransactionBodyDTO;

export type EmbeddedVrfKeyLinkTransactionDTO = EmbeddedTransactionDTO & VrfKeyLinkTransactionBodyDTO;

export interface VotingKeyLinkNetworkPropertiesDTO {
  /** to trigger plugin load */
  dummy?: string;
}

export interface VotingKeyLinkTransactionBodyDTO {
  linkedPublicKey: VotingKey;
  startEpoch: FinalizationEpoch;
  endEpoch: FinalizationEpoch;
  linkAction: LinkActionEnum;
}

/**
 * Transaction to associate a BLS public key with an account.
Required for node operators willing to vote finalized blocks.

 */
export type VotingKeyLinkTransactionDTO = TransactionDTO & VotingKeyLinkTransactionBodyDTO;

export type EmbeddedVotingKeyLinkTransactionDTO = EmbeddedTransactionDTO & VotingKeyLinkTransactionBodyDTO;

export type EmbeddedHashLockTransactionDTO = EmbeddedTransactionDTO & HashLockTransactionBodyDTO;

export interface HashLockEntryDTO {
  version: StateVersion;
  ownerAddress: Address;
  mosaicId: MosaicId;
  amount: Amount;
  endHeight: Height;
  status: LockStatus;
  hash: Hash256;
}

export interface HashLockInfoDTO {
  id: string;
  lock: HashLockEntryDTO;
}

export interface HashLockPage {
  /** Array of hash locks. */
  data: HashLockInfoDTO[];
  pagination: Pagination;
}

export interface HashLockTransactionBodyDTO {
  mosaicId: UnresolvedMosaicId;
  amount: Amount;
  duration: BlockDuration;
  hash: Hash256;
}

/**
 * Transaction to lock funds before sending an aggregate bonded transaction.
 */
export type HashLockTransactionDTO = TransactionDTO & HashLockTransactionBodyDTO;

export interface HashLockNetworkPropertiesDTO {
  /** Amount that has to be locked per aggregate in partial cache. */
  lockedFundsPerAggregate?: string;
  /** Maximum number of blocks for which a hash lock can exist. */
  maxHashLockDuration?: string;
}

/**
 * Algorithm used to hash the proof:
* 0 (Op_Sha3_256) - Proof is hashed using SHA3-256.
* 1 (Op_Hash_160) - Proof is hashed twice: first with SHA-256 and then with RIPEMD-160 (bitcoin's OP_HASH160).
* 2 (Op_Hash_256) - Proof is hashed twice with SHA3-256 (bitcoin's OP_HASH256).

 */
export type LockHashAlgorithmEnum = typeof LockHashAlgorithmEnum[keyof typeof LockHashAlgorithmEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const LockHashAlgorithmEnum = {
  NUMBER_0: 0,
  NUMBER_1: 1,
  NUMBER_2: 2,
} as const;

export type EmbeddedSecretLockTransactionDTO = EmbeddedTransactionDTO & SecretLockTransactionBodyDTO;

export type EmbeddedSecretProofTransactionDTO = EmbeddedTransactionDTO & SecretProofTransactionBodyDTO;

export interface SecretLockEntryDTO {
  version: StateVersion;
  ownerAddress: Address;
  mosaicId: MosaicId;
  amount: Amount;
  endHeight: Height;
  status: LockStatus;
  hashAlgorithm: LockHashAlgorithmEnum;
  secret: Secret;
  recipientAddress: Address;
  compositeHash: Hash256;
}

export interface SecretLockInfoDTO {
  id: string;
  lock: SecretLockEntryDTO;
}

export interface SecretLockPage {
  /** Array of secret locks. */
  data: SecretLockInfoDTO[];
  pagination: Pagination;
}

export interface SecretLockNetworkPropertiesDTO {
  /** Maximum number of blocks for which a secret lock can exist. */
  maxSecretLockDuration?: string;
  /** Minimum size of a proof in bytes. */
  minProofSize?: string;
  /** Maximum size of a proof in bytes. */
  maxProofSize?: string;
}

export interface SecretLockTransactionBodyDTO {
  recipientAddress: UnresolvedAddress;
  secret: Hash256;
  mosaicId: UnresolvedMosaicId;
  amount: Amount;
  duration: BlockDuration;
  hashAlgorithm: LockHashAlgorithmEnum;
}

/**
 * Transaction to sends mosaics to a recipient if the proof used is revealed. If the duration is reached, the locked funds go back to the sender of the transaction.
 */
export type SecretLockTransactionDTO = TransactionDTO & SecretLockTransactionBodyDTO;

export interface SecretProofTransactionBodyDTO {
  recipientAddress: UnresolvedAddress;
  secret: Hash256;
  hashAlgorithm: LockHashAlgorithmEnum;
  /** Original random set of bytes. */
  proof: string;
}

/**
 * Transaction to reveal a proof.
 */
export type SecretProofTransactionDTO = TransactionDTO & SecretProofTransactionBodyDTO;

/**
 * Metadata type:
* 0 - Account.
* 1 - Mosaic.
* 2 - Namespace.

 */
export type MetadataTypeEnum = typeof MetadataTypeEnum[keyof typeof MetadataTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MetadataTypeEnum = {
  NUMBER_0: 0,
  NUMBER_1: 1,
  NUMBER_2: 2,
} as const;

export interface AccountMetadataTransactionBodyDTO {
  targetAddress: UnresolvedAddress;
  scopedMetadataKey: MetadataKey;
  /** Change in value size in bytes. */
  valueSizeDelta: number;
  /** Value size in bytes. */
  valueSize: UInt32;
  value: MetadataValue;
}

/**
 * Transaction to create or modify a multisig account.
 */
export type AccountMetadataTransactionDTO = TransactionDTO & AccountMetadataTransactionBodyDTO;

export type EmbeddedAccountMetadataTransactionDTO = EmbeddedTransactionDTO & AccountMetadataTransactionBodyDTO;

export type EmbeddedMosaicMetadataTransactionDTO = EmbeddedTransactionDTO & MosaicMetadataTransactionBodyDTO;

export type EmbeddedNamespaceMetadataTransactionDTO = EmbeddedTransactionDTO & NamespaceMetadataTransactionBodyDTO;

export type MetadataEntryDTOTargetId = MosaicId | NamespaceId;

export interface MetadataEntryDTO {
  version: StateVersion;
  compositeHash: Hash256;
  sourceAddress: Address;
  targetAddress: Address;
  scopedMetadataKey: MetadataKey;
  targetId?: MetadataEntryDTOTargetId;
  metadataType: MetadataTypeEnum;
  /** Metadata value. */
  value: string;
}

export interface MetadataInfoDTO {
  id: string;
  metadataEntry: MetadataEntryDTO;
}

export interface MetadataNetworkPropertiesDTO {
  /** Maximum metadata value size. */
  maxValueSize?: string;
}

export interface MetadataPage {
  /** Array of metadata entries. */
  data: MetadataInfoDTO[];
  pagination: Pagination;
}

export interface MosaicMetadataTransactionBodyDTO {
  targetAddress: UnresolvedAddress;
  scopedMetadataKey: MetadataKey;
  targetMosaicId: UnresolvedMosaicId;
  /** Change in value size in bytes. */
  valueSizeDelta: number;
  /** Value size in bytes. */
  valueSize: UInt32;
  value: MetadataValue;
}

/**
 * Transaction to create or modify a multisig account.
 */
export type MosaicMetadataTransactionDTO = TransactionDTO & MosaicMetadataTransactionBodyDTO;

export interface NamespaceMetadataTransactionBodyDTO {
  targetAddress: UnresolvedAddress;
  scopedMetadataKey: MetadataKey;
  targetNamespaceId?: NamespaceId;
  /** Change in value size in bytes. */
  valueSizeDelta: number;
  /** Value size in bytes. */
  valueSize: UInt32;
  value: MetadataValue;
}

/**
 * Transaction to create or modify a multisig account.
 */
export type NamespaceMetadataTransactionDTO = TransactionDTO & NamespaceMetadataTransactionBodyDTO;

/**
 * - 0x00 (none) - No flags present.
- 0x01 (supplyMutable) - Mosaic supports supply changes even when mosaic owner owns partial supply.
- 0x02 (transferable) - Mosaic supports transfers between arbitrary accounts. When not set, mosaic can only be transferred to and from mosaic owner.
- 0x04 (restrictable) - Mosaic supports custom restrictions configured by mosaic owner.
- 0x08 (revokable) - Mosaic allows creator to revoke balances from another user.

 */
export type MosaicFlagsEnum = number;

/**
 * Direction of the supply change:
* 0  - Decrease.
* 1  - Increase.

 */
export type MosaicSupplyChangeActionEnum = typeof MosaicSupplyChangeActionEnum[keyof typeof MosaicSupplyChangeActionEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MosaicSupplyChangeActionEnum = {
  NUMBER_0: 0,
  NUMBER_1: 1,
} as const;

export type EmbeddedMosaicDefinitionTransactionDTO = EmbeddedTransactionDTO & MosaicDefinitionTransactionBodyDTO;

export type EmbeddedMosaicSupplyChangeTransactionDTO = EmbeddedTransactionDTO & MosaicSupplyChangeTransactionBodyDTO;

export type EmbeddedMosaicSupplyRevocationTransactionDTO = EmbeddedTransactionDTO & MosaicSupplyRevocationTransactionBodyDTO;

export interface MosaicDefinitionTransactionBodyDTO {
  id: MosaicId;
  duration: BlockDuration;
  /** Random nonce used to generate the mosaic id. */
  nonce: UInt32;
  flags: MosaicFlagsEnum;
  /** Determines up to what decimal place the mosaic can be divided.
Divisibility of 3 means that a mosaic can be divided into smallest parts of 0.001 mosaics.
The divisibility must be in the range of 0 and 6.
 */
  divisibility: number;
}

/**
 * Transaction to create a new mosaic.
 */
export type MosaicDefinitionTransactionDTO = TransactionDTO & MosaicDefinitionTransactionBodyDTO;

export interface MosaicDTO {
  version: StateVersion;
  id: MosaicId;
  supply: Amount;
  startHeight: Height;
  ownerAddress: Address;
  /** Number of definitions for the same mosaic. */
  revision: UInt32;
  flags: MosaicFlagsEnum;
  /** Determines up to what decimal place the mosaic can be divided.
Divisibility of 3 means that a mosaic can be divided into smallest parts of 0.001 mosaics.
The divisibility must be in the range of 0 and 6.
 */
  divisibility: number;
  duration: BlockDuration;
}

export interface MosaicInfoDTO {
  /** Internal resource identifier. */
  id: string;
  mosaic: MosaicDTO;
}

export interface MosaicNetworkPropertiesDTO {
  /** Maximum number of mosaics that an account can own. */
  maxMosaicsPerAccount?: string;
  /** Maximum mosaic duration. */
  maxMosaicDuration?: string;
  /** Maximum mosaic divisibility. */
  maxMosaicDivisibility?: string;
  /** Address of the mosaic rental fee sink account. */
  mosaicRentalFeeSinkAddress?: Address;
  /** Mosaic rental fee. */
  mosaicRentalFee?: string;
}

export interface MosaicPage {
  /** Array of mosaics. */
  data: MosaicInfoDTO[];
  pagination: Pagination;
}

export interface MosaicSupplyChangeTransactionBodyDTO {
  mosaicId: UnresolvedMosaicId;
  delta: Amount;
  action: MosaicSupplyChangeActionEnum;
}

/**
 * Transaction to increase or decrease the supply of a mosaic.
 */
export type MosaicSupplyChangeTransactionDTO = TransactionDTO & MosaicSupplyChangeTransactionBodyDTO;

export interface MosaicSupplyRevocationTransactionBodyDTO {
  sourceAddress: UnresolvedAddress;
  mosaicId: UnresolvedMosaicId;
  amount: Amount;
}

/**
 * Transaction that allows the mosaic creator to revoke some balance from a user.
 */
export type MosaicSupplyRevocationTransactionDTO = TransactionDTO & MosaicSupplyRevocationTransactionBodyDTO;

export type EmbeddedMultisigAccountModificationTransactionDTO = EmbeddedTransactionDTO & MultisigAccountModificationTransactionBodyDTO;

export interface MultisigAccountGraphInfoDTO {
  /** Level of the multisig account. */
  level: number;
  /** Array of multisig accounts for this level. */
  multisigEntries: MultisigAccountInfoDTO[];
}

export interface MultisigAccountInfoDTO {
  multisig: MultisigDTO;
}

export interface MultisigAccountModificationTransactionBodyDTO {
  /** Number of signatures needed to remove a cosignatory.
If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories.
 */
  minRemovalDelta: number;
  /** Number of signatures needed to approve a transaction.
If we are modifying an existing multisig account, this indicates the relative change of the minimum cosignatories.
 */
  minApprovalDelta: number;
  /** Array of cosignatory accounts to add. */
  addressAdditions: UnresolvedAddress[];
  /** Array of cosignatory accounts to delete. */
  addressDeletions: UnresolvedAddress[];
}

/**
 * Transaction to create or modify a multisig account.
 */
export type MultisigAccountModificationTransactionDTO = TransactionDTO & MultisigAccountModificationTransactionBodyDTO;

export interface MultisigDTO {
  version: StateVersion;
  accountAddress: Address;
  /** Number of signatures needed to approve a transaction. */
  minApproval: UInt32;
  /** Number of signatures needed to remove a cosignatory. */
  minRemoval: UInt32;
  /** Addresses of the cosignatory accounts. */
  cosignatoryAddresses: Address[];
  /** Multisig accounts where the account is cosignatory. */
  multisigAddresses: Address[];
}

export interface MultisigNetworkPropertiesDTO {
  /** Maximum number of multisig levels. */
  maxMultisigDepth?: string;
  /** Maximum number of cosignatories per account. */
  maxCosignatoriesPerAccount?: string;
  /** Maximum number of accounts a single account can cosign. */
  maxCosignedAccountsPerAccount?: string;
}

/**
 * Alias action:
* 0 - Unlink alias.
* 1 - Link alias.

 */
export type AliasActionEnum = typeof AliasActionEnum[keyof typeof AliasActionEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AliasActionEnum = {
  NUMBER_0: 0,
  NUMBER_1: 1,
} as const;

/**
 * Type of alias:
* 0 - No alias.
* 1 - Mosaic id alias.
* 2 - Addres alias.

 */
export type AliasTypeEnum = typeof AliasTypeEnum[keyof typeof AliasTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AliasTypeEnum = {
  NUMBER_0: 0,
  NUMBER_1: 1,
  NUMBER_2: 2,
} as const;

/**
 * Type of namespace:
* 0 - Root namespace.
* 1 - Subnamespace.

 */
export type NamespaceRegistrationTypeEnum = typeof NamespaceRegistrationTypeEnum[keyof typeof NamespaceRegistrationTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NamespaceRegistrationTypeEnum = {
  NUMBER_0: 0,
  NUMBER_1: 1,
} as const;

export interface AccountNamesDTO {
  address: Address;
  /** Account linked namespace names. */
  names: string[];
}

export interface AccountsNamesDTO {
  /** Array of account names. */
  accountNames: AccountNamesDTO[];
}

export interface AddressAliasTransactionBodyDTO {
  namespaceId: NamespaceId;
  address: Address;
  aliasAction: AliasActionEnum;
}

/**
 * Transaction to link a namespace to an account.
 */
export type AddressAliasTransactionDTO = TransactionDTO & AddressAliasTransactionBodyDTO;

export interface AliasDTO {
  type: AliasTypeEnum;
  mosaicId?: MosaicId;
  address?: Address;
}

export type EmbeddedAddressAliasTransactionDTO = EmbeddedTransactionDTO & AddressAliasTransactionBodyDTO;

export type EmbeddedMosaicAliasTransactionDTO = EmbeddedTransactionDTO & MosaicAliasTransactionBodyDTO;

export type EmbeddedNamespaceRegistrationTransactionDTO = EmbeddedTransactionDTO & NamespaceRegistrationTransactionBodyDTO;

export interface MosaicAliasTransactionBodyDTO {
  namespaceId: NamespaceId;
  mosaicId: MosaicId;
  aliasAction: AliasActionEnum;
}

/**
 * Transaction to link a namespace to a mosaic.
 */
export type MosaicAliasTransactionDTO = TransactionDTO & MosaicAliasTransactionBodyDTO;

export interface MosaicNamesDTO {
  mosaicId: MosaicId;
  /** Mosaic linked namespace names. */
  names: string[];
}

export interface MosaicsNamesDTO {
  /** Array of mosaic names. */
  mosaicNames: MosaicNamesDTO[];
}

export interface NamespaceInfoDTO {
  /** Internal resource identifier. */
  id: string;
  meta: NamespaceMetaDTO;
  namespace: NamespaceDTO;
}

export interface NamespaceMetaDTO {
  /** If true, the namespace is active. */
  active: boolean;
  index: number;
}

export interface NamespaceDTO {
  version: StateVersion;
  registrationType: NamespaceRegistrationTypeEnum;
  /** Level of the namespace. */
  depth: number;
  level0: NamespaceId;
  level1?: NamespaceId;
  level2?: NamespaceId;
  alias: AliasDTO;
  parentId: NamespaceId;
  ownerAddress: Address;
  startHeight: Height;
  endHeight: Height;
}

export interface NamespaceNameDTO {
  parentId?: NamespaceId;
  id: NamespaceId;
  /** Namespace name. */
  name: string;
}

export interface NamespaceNetworkPropertiesDTO {
  /** Maximum namespace name size. */
  maxNameSize?: string;
  /** Maximum number of children for a root namespace. */
  maxChildNamespaces?: string;
  /** Maximum namespace depth. */
  maxNamespaceDepth?: string;
  /** Minimum namespace duration. */
  minNamespaceDuration?: string;
  /** Maximum namespace duration. */
  maxNamespaceDuration?: string;
  /** Grace period during which time only the previous owner can renew an expired namespace. */
  namespaceGracePeriodDuration?: string;
  /** Reserved root namespaces that cannot be claimed. */
  reservedRootNamespaceNames?: string;
  /** Address of the namespace rental fee sink account. */
  namespaceRentalFeeSinkAddress?: Address;
  /** Root namespace rental fee per block. */
  rootNamespaceRentalFeePerBlock?: string;
  /** Child namespace rental fee. */
  childNamespaceRentalFee?: string;
}

export interface NamespacePage {
  /** Array of namespaces. */
  data: NamespaceInfoDTO[];
  pagination: Pagination;
}

export interface NamespaceRegistrationTransactionBodyDTO {
  duration?: BlockDuration;
  parentId?: NamespaceId;
  id: NamespaceId;
  registrationType: NamespaceRegistrationTypeEnum;
  /** Namespace name. */
  name: string;
}

/**
 * Transaction to create or renew a namespace.
 */
export type NamespaceRegistrationTransactionDTO = TransactionDTO & NamespaceRegistrationTransactionBodyDTO;

/**
 * Type of receipt:
* 0x124D (4685 decimal) - Mosaic_Rental_Fee.
* 0x134E (4942 decimal) - Namespace_Rental_Fee.
* 0x2143 (8515 decimal) - Harvest_Fee.
* 0x2248 (8776 decimal) - LockHash_Completed.
* 0x2348 (9032 decimal) - LockHash_Expired.
* 0x2252 (8786 decimal) - LockSecret_Completed.
* 0x2352 (9042 decimal) - LockSecret_Expired.
* 0x3148 (12616 decimal) - LockHash_Created.
* 0x3152 (12626 decimal) - LockSecret_Created.
* 0x414D (16717 decimal) - Mosaic_Expired.
* 0x414E (16718 decimal) - Namespace_Expired.
* 0x424E (16974 decimal) - Namespace_Deleted.
* 0x5143 (20803 decimal) - Inflation.
* 0xE143 (57667 decimal) - Transaction_Group.
* 0xF143 (61763 decimal) - Address_Alias_Resolution.
* 0xF243 (62019 decimal) - Mosaic_Alias_Resolution.

 */
export type ReceiptTypeEnum = typeof ReceiptTypeEnum[keyof typeof ReceiptTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ReceiptTypeEnum = {
  NUMBER_4685: 4685,
  NUMBER_4942: 4942,
  NUMBER_8515: 8515,
  NUMBER_8776: 8776,
  NUMBER_9032: 9032,
  NUMBER_8786: 8786,
  NUMBER_9042: 9042,
  NUMBER_12616: 12616,
  NUMBER_12626: 12626,
  NUMBER_16717: 16717,
  NUMBER_16718: 16718,
  NUMBER_16974: 16974,
  NUMBER_20803: 20803,
  NUMBER_57667: 57667,
  NUMBER_61763: 61763,
  NUMBER_62019: 62019,
} as const;

export type BalanceTransferReceiptDTOAllOf = {
  mosaicId: MosaicId;
  amount: Amount;
  senderAddress: Address;
  recipientAddress: Address;
};

/**
 * Receipt stored when a state change that triggered a mosaic transfer.
 */
export type BalanceTransferReceiptDTO = ReceiptDTO & BalanceTransferReceiptDTOAllOf;

export type BalanceChangeReceiptDTOAllOf = {
  mosaicId: MosaicId;
  amount: Amount;
  targetAddress: Address;
};

/**
 * Receipt stored when a state change modified an account balance.
 */
export type BalanceChangeReceiptDTO = ReceiptDTO & BalanceChangeReceiptDTOAllOf;

export type NamespaceExpiryReceiptDTOAllOf = {
  artifactId: NamespaceId;
};

/**
 * Receipt stored when a namespace expires.
 */
export type NamespaceExpiryReceiptDTO = ReceiptDTO & NamespaceExpiryReceiptDTOAllOf;

export type MosaicExpiryReceiptDTOAllOf = {
  artifactId: MosaicId;
};

/**
 * Receipt stored when a mosaic expires.
 */
export type MosaicExpiryReceiptDTO = ReceiptDTO & MosaicExpiryReceiptDTOAllOf;

export type InflationReceiptDTOAllOf = {
  mosaicId: MosaicId;
  amount: Amount;
};

/**
 * Receipt stored when network currency mosaics were created due to inflation.
 */
export type InflationReceiptDTO = ReceiptDTO & InflationReceiptDTOAllOf;

export interface ReceiptDTO {
  /** Version of the receipt. */
  version: number;
  type: ReceiptTypeEnum;
}

export type ResolutionEntryDTOResolved = Address | MosaicId;

export interface ResolutionEntryDTO {
  source: SourceDTO;
  resolved: ResolutionEntryDTOResolved;
}

export type ResolutionStatementDTOUnresolved = UnresolvedMosaicId | UnresolvedAddress;

export interface ResolutionStatementDTO {
  height: Height;
  unresolved: ResolutionStatementDTOUnresolved;
  /** Array of resolution entries linked to the unresolved namespaceId.
It is an array instead of a single resolution entry since
within one block the resolution might change for different sources due to alias related transactions.
 */
  resolutionEntries: ResolutionEntryDTO[];
}

/**
 * A resolution statement keeps the relation between a namespace alias used in a transaction
and the real address or mosaicId.

 */
export interface ResolutionStatementInfoDTO {
  /** Internal resource identifier. */
  id: string;
  meta: StatementMetaDTO;
  statement: ResolutionStatementDTO;
}

export interface ResolutionStatementPage {
  /** Array of transaction address resolution statements. */
  data: ResolutionStatementInfoDTO[];
  pagination: Pagination;
}

/**
 * Transaction that triggered the receipt.
 */
export interface SourceDTO {
  /** Transaction index within the block. */
  primaryId: UInt32;
  /** Transaction index within the aggregate transaction.
If the transaction is not an embedded transaction, then the secondary id is set to 0.
 */
  secondaryId: UInt32;
}

/**
 * Metadata related to the statment, including block information.
 */
export interface StatementMetaDTO {
  timestamp: Timestamp;
}

export type TransactionStatementDTOReceiptsItem = BalanceTransferReceiptDTO | BalanceChangeReceiptDTO | NamespaceExpiryReceiptDTO | MosaicExpiryReceiptDTO | InflationReceiptDTO;

export interface TransactionStatementDTO {
  height: Height;
  source: SourceDTO;
  /** Array of receipts. */
  receipts: TransactionStatementDTOReceiptsItem[];
}

/**
 * Collection of receipts related to a transaction.
 */
export interface TransactionStatementInfoDTO {
  /** Internal resource identifier. */
  id: string;
  meta: StatementMetaDTO;
  statement: TransactionStatementDTO;
}

export interface TransactionStatementPage {
  /** Array of transaction statements. */
  data: TransactionStatementInfoDTO[];
  pagination: Pagination;
}

/**
 * Type of account restriction:
* 0x0001 (1 decimal) - Allow only incoming transactions from a given address.
* 0x0002 (2 decimal) - Allow only incoming transactions containing a given mosaic identifier.
* 0x4001 (16385 decimal) - Allow only outgoing transactions to a given address.
* 0x4004 (16388 decimal) - Allow only outgoing transactions with a given transaction type.
* 0x8001 (32769 decimal) - Block incoming transactions from a given address.
* 0x8002 (32770 decimal) - Block incoming transactions containing a given mosaic identifier.
* 0xC001 (49153 decimal) - Block outgoing transactions to a given address.
* 0xC004 (49156 decimal) - Block outgoing transactions with a given transaction type.

 */
export type AccountRestrictionFlagsEnum = typeof AccountRestrictionFlagsEnum[keyof typeof AccountRestrictionFlagsEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AccountRestrictionFlagsEnum = {
  NUMBER_1: 1,
  NUMBER_2: 2,
  NUMBER_16385: 16385,
  NUMBER_16388: 16388,
  NUMBER_32769: 32769,
  NUMBER_32770: 32770,
  NUMBER_49153: 49153,
  NUMBER_49156: 49156,
} as const;

export interface AccountAddressRestrictionTransactionBodyDTO {
  restrictionFlags: AccountRestrictionFlagsEnum;
  /** Account restriction additions. */
  restrictionAdditions: UnresolvedAddress[];
  /** Account restriction deletions. */
  restrictionDeletions: UnresolvedAddress[];
}

/**
 * Transaction to prevent incoming and outgoing transactions for a given a set of addresses.
 */
export type AccountAddressRestrictionTransactionDTO = TransactionDTO & AccountAddressRestrictionTransactionBodyDTO;

export interface AccountMosaicRestrictionTransactionBodyDTO {
  restrictionFlags: AccountRestrictionFlagsEnum;
  /** Account restriction additions. */
  restrictionAdditions: UnresolvedMosaicId[];
  /** Account restriction deletions. */
  restrictionDeletions: UnresolvedMosaicId[];
}

/**
 * Transaction to prevent incoming transactions containing a given set of mosaics.
 */
export type AccountMosaicRestrictionTransactionDTO = TransactionDTO & AccountMosaicRestrictionTransactionBodyDTO;

export interface AccountOperationRestrictionTransactionBodyDTO {
  restrictionFlags: AccountRestrictionFlagsEnum;
  /** Account restriction additions. */
  restrictionAdditions: TransactionTypeEnum[];
  /** Account restriction deletions. */
  restrictionDeletions: TransactionTypeEnum[];
}

/**
 * Transaction to prevent outgoing transactions by transaction type.
 */
export type AccountOperationRestrictionTransactionDTO = TransactionDTO & AccountOperationRestrictionTransactionBodyDTO;

export interface AccountRestrictionsInfoDTO {
  accountRestrictions: AccountRestrictionsDTO;
}

export interface AccountRestrictionsPage {
  /** Array of account restrictions. */
  data: AccountRestrictionsInfoDTO[];
  pagination: Pagination;
}

export interface AccountRestrictionsDTO {
  version: StateVersion;
  address: Address;
  restrictions: AccountRestrictionDTO[];
}

export type AccountRestrictionDTOValuesItem = UnresolvedAddress | UnresolvedMosaicId | TransactionTypeEnum;

export interface AccountRestrictionDTO {
  restrictionFlags: AccountRestrictionFlagsEnum;
  /** Address, mosaic id, or transaction type to restrict. */
  values: AccountRestrictionDTOValuesItem[];
}

export interface AccountRestrictionNetworkPropertiesDTO {
  /** Maximum number of account restriction values. */
  maxAccountRestrictionValues?: string;
}

export type EmbeddedAccountAddressRestrictionTransactionDTO = EmbeddedTransactionDTO & AccountAddressRestrictionTransactionBodyDTO;

export type EmbeddedAccountMosaicRestrictionTransactionDTO = EmbeddedTransactionDTO & AccountMosaicRestrictionTransactionBodyDTO;

export type EmbeddedAccountOperationRestrictionTransactionDTO = EmbeddedTransactionDTO & AccountOperationRestrictionTransactionBodyDTO;

/**
 * - 0 - Mosaic address restriction.
- 1 - Mosaic global restriction.

 */
export type MosaicRestrictionEntryTypeEnum = typeof MosaicRestrictionEntryTypeEnum[keyof typeof MosaicRestrictionEntryTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MosaicRestrictionEntryTypeEnum = {
  NUMBER_0: 0,
  NUMBER_1: 1,
} as const;

/**
 * Type of mosaic restriction.
* 0 - Uninitialized value indicating no restriction.
* 1 (EQ) - Allow if equal.
* 2 (NE) - Allow if not equal.
* 3 (LT) - Allow if less than.
* 4 (LE) - Allow if less than or equal.
* 5 (GT) - Allow if greater than.
* 6 (GE) - Allow if greater than or equal.

 */
export type MosaicRestrictionTypeEnum = typeof MosaicRestrictionTypeEnum[keyof typeof MosaicRestrictionTypeEnum];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MosaicRestrictionTypeEnum = {
  NUMBER_0: 0,
  NUMBER_1: 1,
  NUMBER_2: 2,
  NUMBER_3: 3,
  NUMBER_4: 4,
  NUMBER_5: 5,
  NUMBER_6: 6,
} as const;

export type EmbeddedMosaicAddressRestrictionTransactionDTO = EmbeddedTransactionDTO & MosaicAddressRestrictionTransactionBodyDTO;

export type EmbeddedMosaicGlobalRestrictionTransactionDTO = EmbeddedTransactionDTO & MosaicGlobalRestrictionTransactionBodyDTO;

/**
 * Generic Mosaic Restriction
 */
export type MosaicRestrictionDTO = MosaicAddressRestrictionDTO | MosaicGlobalRestrictionDTO;

export interface MosaicAddressRestrictionDTO {
  /** Internal resource identifier. */
  id: string;
  mosaicRestrictionEntry: MosaicAddressRestrictionEntryWrapperDTO;
}

export interface MosaicAddressRestrictionEntryDTO {
  key: RestrictionKey;
  /** Restriction value. */
  value: string;
}

export interface MosaicAddressRestrictionEntryWrapperDTO {
  version: StateVersion;
  compositeHash: Hash256;
  entryType: MosaicRestrictionEntryTypeEnum;
  mosaicId: MosaicId;
  targetAddress: Address;
  restrictions: MosaicAddressRestrictionEntryDTO[];
}

export interface MosaicAddressRestrictionTransactionBodyDTO {
  mosaicId: UnresolvedMosaicId;
  restrictionKey: RestrictionKey;
  previousRestrictionValue: RestrictionValue;
  newRestrictionValue: RestrictionValue;
  targetAddress: UnresolvedAddress;
}

/**
 * Transaction to set a restriction rule to an address.
 */
export type MosaicAddressRestrictionTransactionDTO = TransactionDTO & MosaicAddressRestrictionTransactionBodyDTO;

export interface MosaicGlobalRestrictionDTO {
  /** Internal resource identifier. */
  id: string;
  mosaicRestrictionEntry: MosaicGlobalRestrictionEntryWrapperDTO;
}

export interface MosaicGlobalRestrictionEntryDTO {
  key: RestrictionKey;
  restriction: MosaicGlobalRestrictionEntryRestrictionDTO;
}

export interface MosaicGlobalRestrictionEntryRestrictionDTO {
  referenceMosaicId: MosaicId;
  restrictionValue: RestrictionValue;
  restrictionType: MosaicRestrictionTypeEnum;
}

export interface MosaicGlobalRestrictionEntryWrapperDTO {
  version: StateVersion;
  compositeHash: Hash256;
  entryType: MosaicRestrictionEntryTypeEnum;
  mosaicId: MosaicId;
  restrictions: MosaicGlobalRestrictionEntryDTO[];
}

export interface MosaicGlobalRestrictionTransactionBodyDTO {
  mosaicId: UnresolvedMosaicId;
  referenceMosaicId: UnresolvedMosaicId;
  restrictionKey: RestrictionKey;
  previousRestrictionValue: RestrictionValue;
  newRestrictionValue: RestrictionValue;
  previousRestrictionType: MosaicRestrictionTypeEnum;
  newRestrictionType: MosaicRestrictionTypeEnum;
}

/**
 * Transaction to set a network-wide restriction rule to a mosaic.
 */
export type MosaicGlobalRestrictionTransactionDTO = TransactionDTO & MosaicGlobalRestrictionTransactionBodyDTO;

export interface MosaicRestrictionNetworkPropertiesDTO {
  /** Maximum number of mosaic restriction values. */
  maxMosaicRestrictionValues?: string;
}

export type MosaicRestrictionsPageDataItem = MosaicAddressRestrictionDTO | MosaicGlobalRestrictionDTO;

export interface MosaicRestrictionsPage {
  /** Array of mosaic restrictions. */
  data: MosaicRestrictionsPageDataItem[];
  pagination: Pagination;
}

export type EmbeddedTransferTransactionDTO = EmbeddedTransactionDTO & TransferTransactionBodyDTO;

export interface TransferNetworkPropertiesDTO {
  /** Maximum transaction message size. */
  maxMessageSize?: string;
}

export interface TransferTransactionBodyDTO {
  recipientAddress: UnresolvedAddress;
  /** Array of mosaics sent to the recipient.
 */
  mosaics: UnresolvedMosaic[];
  /** Transfer transaction message */
  message?: string;
}

/**
 * Transaction to transfer mosaics and a message to another account.
 */
export type TransferTransactionDTO = TransactionDTO & TransferTransactionBodyDTO;

export interface AccountIds {
  /** Array of public keys. */
  publicKeys?: PublicKey[];
  /** Array of addresses. */
  addresses?: Address[];
}

export interface Addresses {
  /** Array of addresses. */
  addresses?: Address[];
}

export interface Cosignature {
  parentHash?: Hash256;
  signature?: Signature;
  signerPublicKey?: PublicKey;
  version?: CosignatureVersion;
}

export interface MosaicIds {
  /** Array of mosaic identifiers. */
  mosaicIds?: MosaicId[];
}

export interface NamespaceIds {
  /** Array of namespace identifiers. */
  namespaceIds?: NamespaceId[];
}

export interface TransactionHashes {
  /** Array of transaction hashes. */
  hashes?: Hash256[];
}

export interface TransactionIds {
  /** Array of transaction identifiers. */
  transactionIds?: string[];
}

export interface TransactionPayload {
  /** Transaction payload in hexadecimal format. */
  payload?: string;
}

/**
 * ResourceNotFound
 */
export type ResourceNotFoundResponse = ModelError;

/**
 * InvalidContent
 */
export type InvalidContentResponse = ModelError;

/**
 * InvalidArgument
 */
export type InvalidArgumentResponse = ModelError;

export type AccountIdsBody = AccountIds;

export type AddressesBody = Addresses;

export type CosignatureBody = Cosignature;

export type MosaicIdsBody = MosaicIds;

export type NamespaceIdsBody = NamespaceIds;

export type TransactionHashesBody = TransactionHashes;

export type TransactionIdsBody = TransactionIds;

export type TransactionPayloadBody = TransactionPayload;

/**
 * Filter by address involved in the transaction.
An account's address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction.
This filter cannot be combined with ``recipientAddress`` and ``signerPublicKey`` query params.

 */
export type AddressQueryParameter = string;

/**
 * Mosaic or namespace identifier
 */
export type ArtifactIdQueryParameter = string;

/**
 * Filter by mosaic identifier.
 */
export type MosaicIdQueryParameter = string;

/**
 * Type of alias:
* 0 - No alias.
* 1 - Mosaic id alias.
* 2 - Addres alias.

 */
export type AliasTypeQueryParameter = typeof AliasTypeQueryParameter[keyof typeof AliasTypeQueryParameter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AliasTypeQueryParameter = {
  NUMBER_0: 0,
  NUMBER_1: 1,
  NUMBER_2: 2,
} as const;

/**
 * Filter by beneficiary address.
 */
export type BeneficiaryAddressQueryParameter = string;

/**
 * When true, the endpoint also returns all the embedded aggregate transactions.
Otherwise, only top-level transactions used to calculate the block transactionsHash are returned.
**Note:** This field does not work when combined with the ``address`` parameter. This is,
embedded transactions containing the address specified through the ``address`` parameter
will not be returned even when used with ``embedded=true``. There is no problem when using
other parameters like ``recipientAddress`` instead.

 */
export type EmbeddedParameter = boolean;

/**
 * - 0 - Mosaic address restriction.
- 1 - Mosaic global restriction.

 */
export type EntryTypeParameter = typeof EntryTypeParameter[keyof typeof EntryTypeParameter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EntryTypeParameter = {
  NUMBER_0: 0,
  NUMBER_1: 1,
} as const;

/**
 * Only blocks with height greater or equal than this one are returned.
 */
export type FromHeightQueryParameter = string;

/**
 * Requires providing the `transferMosaicId` filter.
Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned.

 */
export type FromTransferAmountQueryParameter = string;

/**
 * Filter by block height.
 */
export type HeightQueryParameter = string;

/**
 * Entry id at which to start pagination.
If the ordering parameter is set to -id, the elements returned precede the identifier.
Otherwise, newer elements with respect to the id are returned.

 */
export type IdQueryParameter = string;

/**
 * Metadata type:
* 0 - Account.
* 1 - Mosaic.
* 2 - Namespace.

 */
export type MetadataTypeParameter = typeof MetadataTypeParameter[keyof typeof MetadataTypeParameter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MetadataTypeParameter = {
  NUMBER_0: 0,
  NUMBER_1: 1,
  NUMBER_2: 2,
} as const;

/**
 * Filter by root namespace.
 */
export type Level0QueryParameter = string;

/**
 * Entry id at which to start pagination.
If the ordering parameter is set to -id, the elements returned precede the identifier.
Otherwise, newer elements with respect to the id are returned.

 */
export type OffsetQueryParameter = string;

/**
 * Indicates how to sort the results: 
* ``asc`` - ascending
* ``desc`` - descending

 */
export type OrderQueryParameter = typeof OrderQueryParameter[keyof typeof OrderQueryParameter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderQueryParameter = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type OrderByAccountQueryParameter = typeof OrderByAccountQueryParameter[keyof typeof OrderByAccountQueryParameter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderByAccountQueryParameter = {
  id: 'id',
  balance: 'balance',
} as const;

/**
 * Filter by owner address.
 */
export type OwnerAddressQueryParameter = string;

export type OrderByBlockQueryParameter = typeof OrderByBlockQueryParameter[keyof typeof OrderByBlockQueryParameter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const OrderByBlockQueryParameter = {
  id: 'id',
  height: 'height',
} as const;

/**
 * Filter by page number.
 */
export type PageNumberQueryParameter = number;

/**
 * Select the number of entries to return.
 */
export type PageSizeQueryParameter = number;

/**
 * Filter by receipt type.
To filter by multiple receipt types, add more filter query params like: ``receiptType=8515&receiptType=20803``.

 */
export type ReceiptTypeQueryParameter = ReceiptTypeEnum[];

/**
 * Filter by address of the account receiving the transaction.
 */
export type RecipientAddressQueryParameter = string;

/**
 * Filter by secret.
 */
export type SecretQueryParameter = string;

/**
 * Filter by address sending mosaics.
 */
export type SenderAddressQueryParameter = string;

/**
 * Filter by metadata key.
 */
export type ScopedMetadataKeyQueryParameter = string;

/**
 * Filter by address sending the metadata entry.
 */
export type SourceAddressQueryParameter = string;

/**
 * Type of namespace:
* 0 - Root namespace.
* 1 - Subnamespace.

 */
export type RegistrationTypeQueryParameter = typeof RegistrationTypeQueryParameter[keyof typeof RegistrationTypeQueryParameter];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const RegistrationTypeQueryParameter = {
  NUMBER_0: 0,
  NUMBER_1: 1,
} as const;

/**
 * Filter by public key of the account signing the entity.
 */
export type SignerPublicKeyQueryParameter = string;

/**
 * Filter by namespace or mosaic id.
 */
export type TargetIdQueryParameter = string;

/**
 * Filter by target address.
 */
export type TargetAddressQueryParameter = string;

/**
 * Only blocks with height smaller or equal than this one are returned.
 */
export type ToHeightQueryParameter = string;

/**
 * Requires providing the `transferMosaicId` filter.
Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned.

 */
export type ToTransferAmountQueryParameter = string;

/**
 * Filter by transaction type.
To filter by multiple transaction types, add more filter query params like: ``type=16974&type=16718``.

 */
export type TransactionTypeQueryParameter = TransactionTypeEnum[];

/**
 * Filters transactions involving a specific ``mosaicId``.
 */
export type TransferMosaicIdQueryParameter = string;

export type SearchAccountsParams = {
/**
 * Select the number of entries to return.
 */
pageSize?: PageSizeQueryParameter;
/**
 * Filter by page number.
 */
pageNumber?: PageNumberQueryParameter;
/**
 * Entry id at which to start pagination.
If the ordering parameter is set to -id, the elements returned precede the identifier.
Otherwise, newer elements with respect to the id are returned.

 */
offset?: OffsetQueryParameter;
/**
 * Sort responses in ascending or descending order based on the collection property set on the param ``orderBy``.
If the request does not specify ``orderBy``, REST returns the collection ordered by id.

 */
order?: OrderQueryParameter;
/**
 * Sort responses by the property set.
If ``balance`` option is selected, the request must define the ``mosaicId`` filter.

 */
orderBy?: OrderByAccountQueryParameter;
/**
 * Filter by mosaic identifier.
 */
mosaicId?: MosaicIdQueryParameter;
};

export type SearchBlocksParams = {
/**
 * Filter by public key of the account signing the entity.
 */
signerPublicKey?: SignerPublicKeyQueryParameter;
/**
 * Filter by beneficiary address.
 */
beneficiaryAddress?: BeneficiaryAddressQueryParameter;
/**
 * Select the number of entries to return.
 */
pageSize?: PageSizeQueryParameter;
/**
 * Filter by page number.
 */
pageNumber?: PageNumberQueryParameter;
/**
 * Entry id at which to start pagination.
If the ordering parameter is set to -id, the elements returned precede the identifier.
Otherwise, newer elements with respect to the id are returned.

 */
offset?: OffsetQueryParameter;
/**
 * Sort responses in ascending or descending order based on the collection property set on the param ``orderBy``.
If the request does not specify ``orderBy``, REST returns the collection ordered by id.

 */
order?: OrderQueryParameter;
/**
 * Sort responses by the property set.

 */
orderBy?: OrderByBlockQueryParameter;
};

export type SearchConfirmedTransactionsParams = {
/**
 * Filter by address involved in the transaction.
An account's address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction.
This filter cannot be combined with ``recipientAddress`` and ``signerPublicKey`` query params.

 */
address?: AddressQueryParameter;
/**
 * Filter by address of the account receiving the transaction.
 */
recipientAddress?: RecipientAddressQueryParameter;
/**
 * Filter by public key of the account signing the entity.
 */
signerPublicKey?: SignerPublicKeyQueryParameter;
/**
 * Filter by block height.
 */
height?: HeightQueryParameter;
/**
 * Only blocks with height greater or equal than this one are returned.
 */
fromHeight?: FromHeightQueryParameter;
/**
 * Only blocks with height smaller or equal than this one are returned.
 */
toHeight?: ToHeightQueryParameter;
/**
 * Requires providing the `transferMosaicId` filter.
Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned.

 */
fromTransferAmount?: FromTransferAmountQueryParameter;
/**
 * Requires providing the `transferMosaicId` filter.
Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned.

 */
toTransferAmount?: ToTransferAmountQueryParameter;
/**
 * Filter by transaction type.
To filter by multiple transaction types, add more filter query params like: ``type=16974&type=16718``.

 */
type?: TransactionTypeQueryParameter;
/**
 * When true, the endpoint also returns all the embedded aggregate transactions.
Otherwise, only top-level transactions used to calculate the block transactionsHash are returned.
**Note:** This field does not work when combined with the ``address`` parameter. This is,
embedded transactions containing the address specified through the ``address`` parameter
will not be returned even when used with ``embedded=true``. There is no problem when using
other parameters like ``recipientAddress`` instead.

 */
embedded?: EmbeddedParameter;
/**
 * Filters transactions involving a specific ``mosaicId``.
 */
transferMosaicId?: TransferMosaicIdQueryParameter;
/**
 * Select the number of entries to return.
 */
pageSize?: PageSizeQueryParameter;
/**
 * Filter by page number.
 */
pageNumber?: PageNumberQueryParameter;
/**
 * Entry id at which to start pagination.
If the ordering parameter is set to -id, the elements returned precede the identifier.
Otherwise, newer elements with respect to the id are returned.

 */
offset?: OffsetQueryParameter;
/**
 * Sort responses in ascending or descending order based on the collection property set on the param ``orderBy``.
If the request does not specify ``orderBy``, REST returns the collection ordered by id.

 */
order?: OrderQueryParameter;
};

export type SearchUnconfirmedTransactionsParams = {
/**
 * Filter by address involved in the transaction.
An account's address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction.
This filter cannot be combined with ``recipientAddress`` and ``signerPublicKey`` query params.

 */
address?: AddressQueryParameter;
/**
 * Filter by address of the account receiving the transaction.
 */
recipientAddress?: RecipientAddressQueryParameter;
/**
 * Filter by public key of the account signing the entity.
 */
signerPublicKey?: SignerPublicKeyQueryParameter;
/**
 * Filter by block height.
 */
height?: HeightQueryParameter;
/**
 * Only blocks with height greater or equal than this one are returned.
 */
fromHeight?: FromHeightQueryParameter;
/**
 * Only blocks with height smaller or equal than this one are returned.
 */
toHeight?: ToHeightQueryParameter;
/**
 * Requires providing the `transferMosaicId` filter.
Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned.

 */
fromTransferAmount?: FromTransferAmountQueryParameter;
/**
 * Requires providing the `transferMosaicId` filter.
Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned.

 */
toTransferAmount?: ToTransferAmountQueryParameter;
/**
 * Filter by transaction type.
To filter by multiple transaction types, add more filter query params like: ``type=16974&type=16718``.

 */
type?: TransactionTypeQueryParameter;
/**
 * When true, the endpoint also returns all the embedded aggregate transactions.
Otherwise, only top-level transactions used to calculate the block transactionsHash are returned.
**Note:** This field does not work when combined with the ``address`` parameter. This is,
embedded transactions containing the address specified through the ``address`` parameter
will not be returned even when used with ``embedded=true``. There is no problem when using
other parameters like ``recipientAddress`` instead.

 */
embedded?: EmbeddedParameter;
/**
 * Filters transactions involving a specific ``mosaicId``.
 */
transferMosaicId?: TransferMosaicIdQueryParameter;
/**
 * Select the number of entries to return.
 */
pageSize?: PageSizeQueryParameter;
/**
 * Filter by page number.
 */
pageNumber?: PageNumberQueryParameter;
/**
 * Entry id at which to start pagination.
If the ordering parameter is set to -id, the elements returned precede the identifier.
Otherwise, newer elements with respect to the id are returned.

 */
offset?: OffsetQueryParameter;
/**
 * Sort responses in ascending or descending order based on the collection property set on the param ``orderBy``.
If the request does not specify ``orderBy``, REST returns the collection ordered by id.

 */
order?: OrderQueryParameter;
};

export type SearchPartialTransactionsParams = {
/**
 * Filter by address involved in the transaction.
An account's address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction.
This filter cannot be combined with ``recipientAddress`` and ``signerPublicKey`` query params.

 */
address?: AddressQueryParameter;
/**
 * Filter by address of the account receiving the transaction.
 */
recipientAddress?: RecipientAddressQueryParameter;
/**
 * Filter by public key of the account signing the entity.
 */
signerPublicKey?: SignerPublicKeyQueryParameter;
/**
 * Filter by block height.
 */
height?: HeightQueryParameter;
/**
 * Only blocks with height greater or equal than this one are returned.
 */
fromHeight?: FromHeightQueryParameter;
/**
 * Only blocks with height smaller or equal than this one are returned.
 */
toHeight?: ToHeightQueryParameter;
/**
 * Requires providing the `transferMosaicId` filter.
Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned.

 */
fromTransferAmount?: FromTransferAmountQueryParameter;
/**
 * Requires providing the `transferMosaicId` filter.
Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned.

 */
toTransferAmount?: ToTransferAmountQueryParameter;
/**
 * Filter by transaction type.
To filter by multiple transaction types, add more filter query params like: ``type=16974&type=16718``.

 */
type?: TransactionTypeQueryParameter;
/**
 * When true, the endpoint also returns all the embedded aggregate transactions.
Otherwise, only top-level transactions used to calculate the block transactionsHash are returned.
**Note:** This field does not work when combined with the ``address`` parameter. This is,
embedded transactions containing the address specified through the ``address`` parameter
will not be returned even when used with ``embedded=true``. There is no problem when using
other parameters like ``recipientAddress`` instead.

 */
embedded?: EmbeddedParameter;
/**
 * Filters transactions involving a specific ``mosaicId``.
 */
transferMosaicId?: TransferMosaicIdQueryParameter;
/**
 * Select the number of entries to return.
 */
pageSize?: PageSizeQueryParameter;
/**
 * Filter by page number.
 */
pageNumber?: PageNumberQueryParameter;
/**
 * Entry id at which to start pagination.
If the ordering parameter is set to -id, the elements returned precede the identifier.
Otherwise, newer elements with respect to the id are returned.

 */
offset?: OffsetQueryParameter;
/**
 * Sort responses in ascending or descending order based on the collection property set on the param ``orderBy``.
If the request does not specify ``orderBy``, REST returns the collection ordered by id.

 */
order?: OrderQueryParameter;
};

export type SearchHashLockParams = {
/**
 * Filter by address involved in the transaction.
An account's address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction.
This filter cannot be combined with ``recipientAddress`` and ``signerPublicKey`` query params.

 */
address?: AddressQueryParameter;
/**
 * Select the number of entries to return.
 */
pageSize?: PageSizeQueryParameter;
/**
 * Filter by page number.
 */
pageNumber?: PageNumberQueryParameter;
/**
 * Entry id at which to start pagination.
If the ordering parameter is set to -id, the elements returned precede the identifier.
Otherwise, newer elements with respect to the id are returned.

 */
offset?: OffsetQueryParameter;
/**
 * Sort responses in ascending or descending order based on the collection property set on the param ``orderBy``.
If the request does not specify ``orderBy``, REST returns the collection ordered by id.

 */
order?: OrderQueryParameter;
};

export type SearchSecretLockParams = {
/**
 * Filter by address involved in the transaction.
An account's address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction.
This filter cannot be combined with ``recipientAddress`` and ``signerPublicKey`` query params.

 */
address?: AddressQueryParameter;
/**
 * Filter by secret.
 */
secret?: SecretQueryParameter;
/**
 * Select the number of entries to return.
 */
pageSize?: PageSizeQueryParameter;
/**
 * Filter by page number.
 */
pageNumber?: PageNumberQueryParameter;
/**
 * Entry id at which to start pagination.
If the ordering parameter is set to -id, the elements returned precede the identifier.
Otherwise, newer elements with respect to the id are returned.

 */
offset?: OffsetQueryParameter;
/**
 * Sort responses in ascending or descending order based on the collection property set on the param ``orderBy``.
If the request does not specify ``orderBy``, REST returns the collection ordered by id.

 */
order?: OrderQueryParameter;
};

export type SearchMetadataEntriesParams = {
/**
 * Filter by address sending the metadata entry.
 */
sourceAddress?: SourceAddressQueryParameter;
/**
 * Filter by target address.
 */
targetAddress?: TargetAddressQueryParameter;
/**
 * Filter by metadata key.
 */
scopedMetadataKey?: ScopedMetadataKeyQueryParameter;
/**
 * Filter by namespace or mosaic id.
 */
targetId?: TargetIdQueryParameter;
/**
 * Filter by metadata type.
 */
metadataType?: MetadataTypeParameter;
/**
 * Select the number of entries to return.
 */
pageSize?: PageSizeQueryParameter;
/**
 * Filter by page number.
 */
pageNumber?: PageNumberQueryParameter;
/**
 * Entry id at which to start pagination.
If the ordering parameter is set to -id, the elements returned precede the identifier.
Otherwise, newer elements with respect to the id are returned.

 */
offset?: OffsetQueryParameter;
/**
 * Sort responses in ascending or descending order based on the collection property set on the param ``orderBy``.
If the request does not specify ``orderBy``, REST returns the collection ordered by id.

 */
order?: OrderQueryParameter;
};

export type SearchMosaicsParams = {
/**
 * Filter by owner address.
 */
ownerAddress?: OwnerAddressQueryParameter;
/**
 * Select the number of entries to return.
 */
pageSize?: PageSizeQueryParameter;
/**
 * Filter by page number.
 */
pageNumber?: PageNumberQueryParameter;
/**
 * Entry id at which to start pagination.
If the ordering parameter is set to -id, the elements returned precede the identifier.
Otherwise, newer elements with respect to the id are returned.

 */
offset?: OffsetQueryParameter;
/**
 * Sort responses in ascending or descending order based on the collection property set on the param ``orderBy``.
If the request does not specify ``orderBy``, REST returns the collection ordered by id.

 */
order?: OrderQueryParameter;
};

export type SearchNamespacesParams = {
/**
 * Filter by owner address.
 */
ownerAddress?: OwnerAddressQueryParameter;
/**
 * Filter by registration type.
 */
registrationType?: RegistrationTypeQueryParameter;
/**
 * Filter by root namespace.
 */
level0?: Level0QueryParameter;
/**
 * Filter by alias type.
 */
aliasType?: AliasTypeQueryParameter;
/**
 * Select the number of entries to return.
 */
pageSize?: PageSizeQueryParameter;
/**
 * Filter by page number.
 */
pageNumber?: PageNumberQueryParameter;
/**
 * Entry id at which to start pagination.
If the ordering parameter is set to -id, the elements returned precede the identifier.
Otherwise, newer elements with respect to the id are returned.

 */
offset?: OffsetQueryParameter;
/**
 * Sort responses in ascending or descending order based on the collection property set on the param ``orderBy``.
If the request does not specify ``orderBy``, REST returns the collection ordered by id.

 */
order?: OrderQueryParameter;
};

export type SearchReceiptsParams = {
/**
 * Filter by block height.
 */
height?: HeightQueryParameter;
/**
 * Only blocks with height greater or equal than this one are returned.
 */
fromHeight?: FromHeightQueryParameter;
/**
 * Only blocks with height smaller or equal than this one are returned.
 */
toHeight?: ToHeightQueryParameter;
/**
 * Filter by receipt type.
To filter by multiple receipt types, add more filter query params like: ``receiptType=8515&receiptType=20803``.

 */
receiptType?: ReceiptTypeQueryParameter;
/**
 * Filter by address of the account receiving the transaction.
 */
recipientAddress?: RecipientAddressQueryParameter;
/**
 * Filter by address sending mosaics.
 */
senderAddress?: SenderAddressQueryParameter;
/**
 * Filter by target address.
 */
targetAddress?: TargetAddressQueryParameter;
/**
 * Mosaic or namespace identifier
 */
artifactId?: ArtifactIdQueryParameter;
/**
 * Select the number of entries to return.
 */
pageSize?: PageSizeQueryParameter;
/**
 * Filter by page number.
 */
pageNumber?: PageNumberQueryParameter;
/**
 * Entry id at which to start pagination.
If the ordering parameter is set to -id, the elements returned precede the identifier.
Otherwise, newer elements with respect to the id are returned.

 */
offset?: OffsetQueryParameter;
/**
 * Sort responses in ascending or descending order based on the collection property set on the param ``orderBy``.
If the request does not specify ``orderBy``, REST returns the collection ordered by id.

 */
order?: OrderQueryParameter;
};

export type SearchAddressResolutionStatementsParams = {
/**
 * Filter by block height.
 */
height?: HeightQueryParameter;
/**
 * Select the number of entries to return.
 */
pageSize?: PageSizeQueryParameter;
/**
 * Filter by page number.
 */
pageNumber?: PageNumberQueryParameter;
/**
 * Entry id at which to start pagination.
If the ordering parameter is set to -id, the elements returned precede the identifier.
Otherwise, newer elements with respect to the id are returned.

 */
offset?: OffsetQueryParameter;
/**
 * Sort responses in ascending or descending order based on the collection property set on the param ``orderBy``.
If the request does not specify ``orderBy``, REST returns the collection ordered by id.

 */
order?: OrderQueryParameter;
};

export type SearchMosaicResolutionStatementsParams = {
/**
 * Filter by block height.
 */
height?: HeightQueryParameter;
/**
 * Select the number of entries to return.
 */
pageSize?: PageSizeQueryParameter;
/**
 * Filter by page number.
 */
pageNumber?: PageNumberQueryParameter;
/**
 * Entry id at which to start pagination.
If the ordering parameter is set to -id, the elements returned precede the identifier.
Otherwise, newer elements with respect to the id are returned.

 */
offset?: OffsetQueryParameter;
/**
 * Sort responses in ascending or descending order based on the collection property set on the param ``orderBy``.
If the request does not specify ``orderBy``, REST returns the collection ordered by id.

 */
order?: OrderQueryParameter;
};

export type SearchAccountRestrictionsParams = {
/**
 * Filter by address involved in the transaction.
An account's address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction.
This filter cannot be combined with ``recipientAddress`` and ``signerPublicKey`` query params.

 */
address?: AddressQueryParameter;
/**
 * Select the number of entries to return.
 */
pageSize?: PageSizeQueryParameter;
/**
 * Filter by page number.
 */
pageNumber?: PageNumberQueryParameter;
/**
 * Entry id at which to start pagination.
If the ordering parameter is set to -id, the elements returned precede the identifier.
Otherwise, newer elements with respect to the id are returned.

 */
offset?: OffsetQueryParameter;
/**
 * Sort responses in ascending or descending order based on the collection property set on the param ``orderBy``.
If the request does not specify ``orderBy``, REST returns the collection ordered by id.

 */
order?: OrderQueryParameter;
};

export type SearchMosaicRestrictionsParams = {
/**
 * Filter by mosaic identifier.
 */
mosaicId?: MosaicIdQueryParameter;
/**
 * Filter by entry type.
 */
entryType?: EntryTypeParameter;
/**
 * Filter by target address.
 */
targetAddress?: TargetAddressQueryParameter;
/**
 * Select the number of entries to return.
 */
pageSize?: PageSizeQueryParameter;
/**
 * Filter by page number.
 */
pageNumber?: PageNumberQueryParameter;
/**
 * Entry id at which to start pagination.
If the ordering parameter is set to -id, the elements returned precede the identifier.
Otherwise, newer elements with respect to the id are returned.

 */
offset?: OffsetQueryParameter;
/**
 * Sort responses in ascending or descending order based on the collection property set on the param ``orderBy``.
If the request does not specify ``orderBy``, REST returns the collection ordered by id.

 */
order?: OrderQueryParameter;
};

type AwaitedInput<T> = PromiseLike<T> | T;

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;




/**
 * Gets an array of accounts.
 * @summary Search accounts
 */
export const searchAccounts = (
    params?: SearchAccountsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccountPage>> => {
    
    
    return axios.get(
      `/accounts`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSearchAccountsQueryKey = (params?: SearchAccountsParams,) => {
    return [`/accounts`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchAccountsQueryOptions = <TData = Awaited<ReturnType<typeof searchAccounts>>, TError = AxiosError<InvalidArgumentResponse>>(params?: SearchAccountsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchAccounts>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchAccountsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchAccounts>>> = ({ signal }) => searchAccounts(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchAccounts>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchAccountsQueryResult = NonNullable<Awaited<ReturnType<typeof searchAccounts>>>
export type SearchAccountsQueryError = AxiosError<InvalidArgumentResponse>


/**
 * @summary Search accounts
 */

export function useSearchAccounts<TData = Awaited<ReturnType<typeof searchAccounts>>, TError = AxiosError<InvalidArgumentResponse>>(
 params?: SearchAccountsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchAccounts>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getSearchAccountsQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns the account information for an array of accounts.
 * @summary Get accounts information
 */
export const getAccountsInfo = (
    accountIdsBody?: AccountIdsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccountInfoDTO[]>> => {
    
    
    return axios.post(
      `/accounts`,
      accountIdsBody,options
    );
  }



export const getGetAccountsInfoMutationOptions = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getAccountsInfo>>, TError,{data: AccountIdsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof getAccountsInfo>>, TError,{data: AccountIdsBody}, TContext> => {

const mutationKey = ['getAccountsInfo'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getAccountsInfo>>, {data: AccountIdsBody}> = (props) => {
          const {data} = props ?? {};

          return  getAccountsInfo(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetAccountsInfoMutationResult = NonNullable<Awaited<ReturnType<typeof getAccountsInfo>>>
    export type GetAccountsInfoMutationBody = AccountIdsBody
    export type GetAccountsInfoMutationError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>

    /**
 * @summary Get accounts information
 */
export const useGetAccountsInfo = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getAccountsInfo>>, TError,{data: AccountIdsBody}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof getAccountsInfo>>,
        TError,
        {data: AccountIdsBody},
        TContext
      > => {

      const mutationOptions = getGetAccountsInfoMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Returns the account information.
 * @summary Get account information
 */
export const getAccountInfo = (
    accountId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccountInfoDTO>> => {
    
    
    return axios.get(
      `/accounts/${accountId}`,options
    );
  }


export const getGetAccountInfoQueryKey = (accountId: string,) => {
    return [`/accounts/${accountId}`] as const;
    }

    
export const getGetAccountInfoQueryOptions = <TData = Awaited<ReturnType<typeof getAccountInfo>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(accountId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAccountInfo>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAccountInfoQueryKey(accountId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccountInfo>>> = ({ signal }) => getAccountInfo(accountId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAccountInfo>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAccountInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getAccountInfo>>>
export type GetAccountInfoQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get account information
 */

export function useGetAccountInfo<TData = Awaited<ReturnType<typeof getAccountInfo>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 accountId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAccountInfo>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAccountInfoQueryOptions(accountId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns the account merkle information.
 * @summary Get account merkle information
 */
export const getAccountInfoMerkle = (
    accountId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MerkleStateInfoDTO>> => {
    
    
    return axios.get(
      `/accounts/${accountId}/merkle`,options
    );
  }


export const getGetAccountInfoMerkleQueryKey = (accountId: string,) => {
    return [`/accounts/${accountId}/merkle`] as const;
    }

    
export const getGetAccountInfoMerkleQueryOptions = <TData = Awaited<ReturnType<typeof getAccountInfoMerkle>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(accountId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAccountInfoMerkle>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAccountInfoMerkleQueryKey(accountId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccountInfoMerkle>>> = ({ signal }) => getAccountInfoMerkle(accountId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAccountInfoMerkle>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAccountInfoMerkleQueryResult = NonNullable<Awaited<ReturnType<typeof getAccountInfoMerkle>>>
export type GetAccountInfoMerkleQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get account merkle information
 */

export function useGetAccountInfoMerkle<TData = Awaited<ReturnType<typeof getAccountInfoMerkle>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 accountId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAccountInfoMerkle>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAccountInfoMerkleQueryOptions(accountId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Gets an array of bocks.
 * @summary Search blocks
 */
export const searchBlocks = (
    params?: SearchBlocksParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BlockPage>> => {
    
    
    return axios.get(
      `/blocks`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSearchBlocksQueryKey = (params?: SearchBlocksParams,) => {
    return [`/blocks`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchBlocksQueryOptions = <TData = Awaited<ReturnType<typeof searchBlocks>>, TError = AxiosError<InvalidArgumentResponse>>(params?: SearchBlocksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchBlocks>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchBlocksQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchBlocks>>> = ({ signal }) => searchBlocks(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchBlocks>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchBlocksQueryResult = NonNullable<Awaited<ReturnType<typeof searchBlocks>>>
export type SearchBlocksQueryError = AxiosError<InvalidArgumentResponse>


/**
 * @summary Search blocks
 */

export function useSearchBlocks<TData = Awaited<ReturnType<typeof searchBlocks>>, TError = AxiosError<InvalidArgumentResponse>>(
 params?: SearchBlocksParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchBlocks>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getSearchBlocksQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Gets a block from the chain that has the given height.
 * @summary Get block information
 */
export const getBlockByHeight = (
    height: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BlockInfoDTO>> => {
    
    
    return axios.get(
      `/blocks/${height}`,options
    );
  }


export const getGetBlockByHeightQueryKey = (height: string,) => {
    return [`/blocks/${height}`] as const;
    }

    
export const getGetBlockByHeightQueryOptions = <TData = Awaited<ReturnType<typeof getBlockByHeight>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(height: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getBlockByHeight>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetBlockByHeightQueryKey(height);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getBlockByHeight>>> = ({ signal }) => getBlockByHeight(height, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(height), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getBlockByHeight>>, TError, TData> & { queryKey: QueryKey }
}

export type GetBlockByHeightQueryResult = NonNullable<Awaited<ReturnType<typeof getBlockByHeight>>>
export type GetBlockByHeightQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get block information
 */

export function useGetBlockByHeight<TData = Awaited<ReturnType<typeof getBlockByHeight>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 height: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getBlockByHeight>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetBlockByHeightQueryOptions(height,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns the merkle path for a transaction included in a block.
The merkle path is the minimum number of nodes needed to calculate the merkle root.

Steps to calculate the merkle root:
1. proofHash = hash (leaf).
2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows:
* a) If item.position == left -> proofHash = sha_256(item.hash + proofHash).
* b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash).
3. Repeat 2. for every item in the merklePath list.
4. Compare if the calculated proofHash equals the one recorded in the
block header (block.transactionsHash) to verify if the transaction was included in the block.

 * @summary Get the merkle path for a given a transaction and block
 */
export const getMerkleTransaction = (
    height: string,
    hash: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MerkleProofInfoDTO>> => {
    
    
    return axios.get(
      `/blocks/${height}/transactions/${hash}/merkle`,options
    );
  }


export const getGetMerkleTransactionQueryKey = (height: string,
    hash: string,) => {
    return [`/blocks/${height}/transactions/${hash}/merkle`] as const;
    }

    
export const getGetMerkleTransactionQueryOptions = <TData = Awaited<ReturnType<typeof getMerkleTransaction>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(height: string,
    hash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMerkleTransaction>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMerkleTransactionQueryKey(height,hash);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMerkleTransaction>>> = ({ signal }) => getMerkleTransaction(height,hash, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(height && hash), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMerkleTransaction>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMerkleTransactionQueryResult = NonNullable<Awaited<ReturnType<typeof getMerkleTransaction>>>
export type GetMerkleTransactionQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get the merkle path for a given a transaction and block
 */

export function useGetMerkleTransaction<TData = Awaited<ReturnType<typeof getMerkleTransaction>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 height: string,
    hash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMerkleTransaction>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMerkleTransactionQueryOptions(height,hash,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns the merkle path for a receipt statement or resolution linked to a block.
The merkle path is the minimum number of nodes needed to calculate the merkle root.

Steps to calculate the merkle root:
1. proofHash = hash (leaf).
2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows:
* a) If item.position == left -> proofHash = sha_256(item.hash + proofHash).
* b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash).
3. Repeat 2. for every item in the merklePath list.
4. Compare if the calculated proofHash equals the one recorded in the
block header (block.receiptsHash) to verify if the statement was linked with the block.

 * @summary Get the merkle path for a given a receipt statement hash and block
 */
export const getMerkleReceipts = (
    height: string,
    hash: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MerkleProofInfoDTO>> => {
    
    
    return axios.get(
      `/blocks/${height}/statements/${hash}/merkle`,options
    );
  }


export const getGetMerkleReceiptsQueryKey = (height: string,
    hash: string,) => {
    return [`/blocks/${height}/statements/${hash}/merkle`] as const;
    }

    
export const getGetMerkleReceiptsQueryOptions = <TData = Awaited<ReturnType<typeof getMerkleReceipts>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(height: string,
    hash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMerkleReceipts>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMerkleReceiptsQueryKey(height,hash);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMerkleReceipts>>> = ({ signal }) => getMerkleReceipts(height,hash, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(height && hash), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMerkleReceipts>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMerkleReceiptsQueryResult = NonNullable<Awaited<ReturnType<typeof getMerkleReceipts>>>
export type GetMerkleReceiptsQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get the merkle path for a given a receipt statement hash and block
 */

export function useGetMerkleReceipts<TData = Awaited<ReturnType<typeof getMerkleReceipts>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 height: string,
    hash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMerkleReceipts>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMerkleReceiptsQueryOptions(height,hash,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns the current information of the blockchain.

The higher the score, the better the chain.
During synchronization, nodes try to get the best blockchain in the network.

The score for a block is derived from its difficulty and the time (in seconds) that has elapsed since the last block:

    block score = difficulty ‚àí time elapsed since last block

 * @summary Get the current information of the chain
 */
export const getChainInfo = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ChainInfoDTO>> => {
    
    
    return axios.get(
      `/chain/info`,options
    );
  }


export const getGetChainInfoQueryKey = () => {
    return [`/chain/info`] as const;
    }

    
export const getGetChainInfoQueryOptions = <TData = Awaited<ReturnType<typeof getChainInfo>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getChainInfo>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetChainInfoQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getChainInfo>>> = ({ signal }) => getChainInfo({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getChainInfo>>, TError, TData> & { queryKey: QueryKey }
}

export type GetChainInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getChainInfo>>>
export type GetChainInfoQueryError = AxiosError<unknown>


/**
 * @summary Get the current information of the chain
 */

export function useGetChainInfo<TData = Awaited<ReturnType<typeof getChainInfo>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getChainInfo>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetChainInfoQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Gets finalization proof for the greatest height associated with the given epoch.
 * @summary Get finalization proof
 */
export const getFinalizationProofAtEpoch = (
    epoch: FinalizationEpoch, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FinalizationProofDTO>> => {
    
    
    return axios.get(
      `/finalization/proof/epoch/${epoch}`,options
    );
  }


export const getGetFinalizationProofAtEpochQueryKey = (epoch: FinalizationEpoch,) => {
    return [`/finalization/proof/epoch/${epoch}`] as const;
    }

    
export const getGetFinalizationProofAtEpochQueryOptions = <TData = Awaited<ReturnType<typeof getFinalizationProofAtEpoch>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(epoch: FinalizationEpoch, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getFinalizationProofAtEpoch>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFinalizationProofAtEpochQueryKey(epoch);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFinalizationProofAtEpoch>>> = ({ signal }) => getFinalizationProofAtEpoch(epoch, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(epoch), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFinalizationProofAtEpoch>>, TError, TData> & { queryKey: QueryKey }
}

export type GetFinalizationProofAtEpochQueryResult = NonNullable<Awaited<ReturnType<typeof getFinalizationProofAtEpoch>>>
export type GetFinalizationProofAtEpochQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get finalization proof
 */

export function useGetFinalizationProofAtEpoch<TData = Awaited<ReturnType<typeof getFinalizationProofAtEpoch>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 epoch: FinalizationEpoch, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getFinalizationProofAtEpoch>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetFinalizationProofAtEpochQueryOptions(epoch,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Gets finalization proof at the given height.
 * @summary Get finalization proof
 */
export const getFinalizationProofAtHeight = (
    height: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<FinalizationProofDTO>> => {
    
    
    return axios.get(
      `/finalization/proof/height/${height}`,options
    );
  }


export const getGetFinalizationProofAtHeightQueryKey = (height: string,) => {
    return [`/finalization/proof/height/${height}`] as const;
    }

    
export const getGetFinalizationProofAtHeightQueryOptions = <TData = Awaited<ReturnType<typeof getFinalizationProofAtHeight>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(height: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getFinalizationProofAtHeight>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetFinalizationProofAtHeightQueryKey(height);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getFinalizationProofAtHeight>>> = ({ signal }) => getFinalizationProofAtHeight(height, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(height), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getFinalizationProofAtHeight>>, TError, TData> & { queryKey: QueryKey }
}

export type GetFinalizationProofAtHeightQueryResult = NonNullable<Awaited<ReturnType<typeof getFinalizationProofAtHeight>>>
export type GetFinalizationProofAtHeightQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get finalization proof
 */

export function useGetFinalizationProofAtHeight<TData = Awaited<ReturnType<typeof getFinalizationProofAtHeight>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 height: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getFinalizationProofAtHeight>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetFinalizationProofAtHeightQueryOptions(height,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns the current network type.
 * @summary Get the current network type of the chain
 */
export const getNetworkType = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<NetworkTypeDTO>> => {
    
    
    return axios.get(
      `/network`,options
    );
  }


export const getGetNetworkTypeQueryKey = () => {
    return [`/network`] as const;
    }

    
export const getGetNetworkTypeQueryOptions = <TData = Awaited<ReturnType<typeof getNetworkType>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNetworkType>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNetworkTypeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNetworkType>>> = ({ signal }) => getNetworkType({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNetworkType>>, TError, TData> & { queryKey: QueryKey }
}

export type GetNetworkTypeQueryResult = NonNullable<Awaited<ReturnType<typeof getNetworkType>>>
export type GetNetworkTypeQueryError = AxiosError<unknown>


/**
 * @summary Get the current network type of the chain
 */

export function useGetNetworkType<TData = Awaited<ReturnType<typeof getNetworkType>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNetworkType>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetNetworkTypeQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns the estimated effective rental fees for namespaces and mosaics.
This endpoint is only available if the REST instance has access to catapult-server ``resources/config-network.properties`` file.
To activate this feature, add the setting "network.propertiesFilePath" in the configuration file (rest/resources/rest.json).

 * @summary Get rental fees information
 */
export const getRentalFees = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RentalFeesDTO>> => {
    
    
    return axios.get(
      `/network/fees/rental`,options
    );
  }


export const getGetRentalFeesQueryKey = () => {
    return [`/network/fees/rental`] as const;
    }

    
export const getGetRentalFeesQueryOptions = <TData = Awaited<ReturnType<typeof getRentalFees>>, TError = AxiosError<InvalidArgumentResponse>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRentalFees>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetRentalFeesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getRentalFees>>> = ({ signal }) => getRentalFees({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getRentalFees>>, TError, TData> & { queryKey: QueryKey }
}

export type GetRentalFeesQueryResult = NonNullable<Awaited<ReturnType<typeof getRentalFees>>>
export type GetRentalFeesQueryError = AxiosError<InvalidArgumentResponse>


/**
 * @summary Get rental fees information
 */

export function useGetRentalFees<TData = Awaited<ReturnType<typeof getRentalFees>>, TError = AxiosError<InvalidArgumentResponse>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getRentalFees>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetRentalFeesQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns the average, median, highest and lower fee multiplier over the last "numBlocksTransactionFeeStats".
The setting "numBlocksTransactionFeeStats" is adjustable via the configuration file (rest/resources/rest.json) per REST instance.

 * @summary Get transaction fees information
 */
export const getTransactionFees = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionFeesDTO>> => {
    
    
    return axios.get(
      `/network/fees/transaction`,options
    );
  }


export const getGetTransactionFeesQueryKey = () => {
    return [`/network/fees/transaction`] as const;
    }

    
export const getGetTransactionFeesQueryOptions = <TData = Awaited<ReturnType<typeof getTransactionFees>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTransactionFees>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTransactionFeesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransactionFees>>> = ({ signal }) => getTransactionFees({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTransactionFees>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTransactionFeesQueryResult = NonNullable<Awaited<ReturnType<typeof getTransactionFees>>>
export type GetTransactionFeesQueryError = AxiosError<unknown>


/**
 * @summary Get transaction fees information
 */

export function useGetTransactionFees<TData = Awaited<ReturnType<typeof getTransactionFees>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTransactionFees>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetTransactionFeesQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns the content from a catapult-server network configuration file (resources/config-network.properties).
To enable this feature, the REST setting "network.propertiesFilePath" must define where the file is located.
This is adjustable via the configuration file (rest/resources/rest.json) per REST instance.

 * @summary Get the network properties
 */
export const getNetworkProperties = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<NetworkConfigurationDTO>> => {
    
    
    return axios.get(
      `/network/properties`,options
    );
  }


export const getGetNetworkPropertiesQueryKey = () => {
    return [`/network/properties`] as const;
    }

    
export const getGetNetworkPropertiesQueryOptions = <TData = Awaited<ReturnType<typeof getNetworkProperties>>, TError = AxiosError<InvalidArgumentResponse>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNetworkProperties>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNetworkPropertiesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNetworkProperties>>> = ({ signal }) => getNetworkProperties({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNetworkProperties>>, TError, TData> & { queryKey: QueryKey }
}

export type GetNetworkPropertiesQueryResult = NonNullable<Awaited<ReturnType<typeof getNetworkProperties>>>
export type GetNetworkPropertiesQueryError = AxiosError<InvalidArgumentResponse>


/**
 * @summary Get the network properties
 */

export function useGetNetworkProperties<TData = Awaited<ReturnType<typeof getNetworkProperties>>, TError = AxiosError<InvalidArgumentResponse>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNetworkProperties>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetNetworkPropertiesQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Supplies information regarding the connection and services status.
 * @summary Get the node health information
 */
export const getNodeHealth = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<NodeHealthInfoDTO>> => {
    
    
    return axios.get(
      `/node/health`,options
    );
  }


export const getGetNodeHealthQueryKey = () => {
    return [`/node/health`] as const;
    }

    
export const getGetNodeHealthQueryOptions = <TData = Awaited<ReturnType<typeof getNodeHealth>>, TError = AxiosError<NodeHealthInfoDTO>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNodeHealth>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNodeHealthQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeHealth>>> = ({ signal }) => getNodeHealth({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNodeHealth>>, TError, TData> & { queryKey: QueryKey }
}

export type GetNodeHealthQueryResult = NonNullable<Awaited<ReturnType<typeof getNodeHealth>>>
export type GetNodeHealthQueryError = AxiosError<NodeHealthInfoDTO>


/**
 * @summary Get the node health information
 */

export function useGetNodeHealth<TData = Awaited<ReturnType<typeof getNodeHealth>>, TError = AxiosError<NodeHealthInfoDTO>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNodeHealth>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetNodeHealthQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Supplies additional information about the application running on a node.
 * @summary Get the node information
 */
export const getNodeInfo = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<NodeInfoDTO>> => {
    
    
    return axios.get(
      `/node/info`,options
    );
  }


export const getGetNodeInfoQueryKey = () => {
    return [`/node/info`] as const;
    }

    
export const getGetNodeInfoQueryOptions = <TData = Awaited<ReturnType<typeof getNodeInfo>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNodeInfo>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNodeInfoQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeInfo>>> = ({ signal }) => getNodeInfo({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNodeInfo>>, TError, TData> & { queryKey: QueryKey }
}

export type GetNodeInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getNodeInfo>>>
export type GetNodeInfoQueryError = AxiosError<unknown>


/**
 * @summary Get the node information
 */

export function useGetNodeInfo<TData = Awaited<ReturnType<typeof getNodeInfo>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNodeInfo>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetNodeInfoQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Gets the list of peers visible by the node.
 * @summary Get peers information
 */
export const getNodePeers = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<NodeInfoDTO[]>> => {
    
    
    return axios.get(
      `/node/peers`,options
    );
  }


export const getGetNodePeersQueryKey = () => {
    return [`/node/peers`] as const;
    }

    
export const getGetNodePeersQueryOptions = <TData = Awaited<ReturnType<typeof getNodePeers>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNodePeers>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNodePeersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodePeers>>> = ({ signal }) => getNodePeers({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNodePeers>>, TError, TData> & { queryKey: QueryKey }
}

export type GetNodePeersQueryResult = NonNullable<Awaited<ReturnType<typeof getNodePeers>>>
export type GetNodePeersQueryError = AxiosError<unknown>


/**
 * @summary Get peers information
 */

export function useGetNodePeers<TData = Awaited<ReturnType<typeof getNodePeers>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNodePeers>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetNodePeersQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns storage information about the node.
 * @summary Get the storage information of the node
 */
export const getNodeStorage = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StorageInfoDTO>> => {
    
    
    return axios.get(
      `/node/storage`,options
    );
  }


export const getGetNodeStorageQueryKey = () => {
    return [`/node/storage`] as const;
    }

    
export const getGetNodeStorageQueryOptions = <TData = Awaited<ReturnType<typeof getNodeStorage>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNodeStorage>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNodeStorageQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeStorage>>> = ({ signal }) => getNodeStorage({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNodeStorage>>, TError, TData> & { queryKey: QueryKey }
}

export type GetNodeStorageQueryResult = NonNullable<Awaited<ReturnType<typeof getNodeStorage>>>
export type GetNodeStorageQueryError = AxiosError<unknown>


/**
 * @summary Get the storage information of the node
 */

export function useGetNodeStorage<TData = Awaited<ReturnType<typeof getNodeStorage>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNodeStorage>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetNodeStorageQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Gets the node time at the moment the reply was sent and received.
 * @summary Get the node time
 */
export const getNodeTime = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<NodeTimeDTO>> => {
    
    
    return axios.get(
      `/node/time`,options
    );
  }


export const getGetNodeTimeQueryKey = () => {
    return [`/node/time`] as const;
    }

    
export const getGetNodeTimeQueryOptions = <TData = Awaited<ReturnType<typeof getNodeTime>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNodeTime>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNodeTimeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNodeTime>>> = ({ signal }) => getNodeTime({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNodeTime>>, TError, TData> & { queryKey: QueryKey }
}

export type GetNodeTimeQueryResult = NonNullable<Awaited<ReturnType<typeof getNodeTime>>>
export type GetNodeTimeQueryError = AxiosError<unknown>


/**
 * @summary Get the node time
 */

export function useGetNodeTime<TData = Awaited<ReturnType<typeof getNodeTime>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNodeTime>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetNodeTimeQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns the version of the running catapult-rest component.
 * @summary Get the version of the running REST component
 */
export const getServerInfo = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ServerInfoDTO>> => {
    
    
    return axios.get(
      `/node/server`,options
    );
  }


export const getGetServerInfoQueryKey = () => {
    return [`/node/server`] as const;
    }

    
export const getGetServerInfoQueryOptions = <TData = Awaited<ReturnType<typeof getServerInfo>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getServerInfo>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetServerInfoQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getServerInfo>>> = ({ signal }) => getServerInfo({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getServerInfo>>, TError, TData> & { queryKey: QueryKey }
}

export type GetServerInfoQueryResult = NonNullable<Awaited<ReturnType<typeof getServerInfo>>>
export type GetServerInfoQueryError = AxiosError<unknown>


/**
 * @summary Get the version of the running REST component
 */

export function useGetServerInfo<TData = Awaited<ReturnType<typeof getServerInfo>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getServerInfo>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetServerInfoQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns array of unlocked account public keys.
 * @summary Get the unlocked harvesting account public keys.
 */
export const getUnlockedAccount = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UnlockedAccountDTO>> => {
    
    
    return axios.get(
      `/node/unlockedaccount`,options
    );
  }


export const getGetUnlockedAccountQueryKey = () => {
    return [`/node/unlockedaccount`] as const;
    }

    
export const getGetUnlockedAccountQueryOptions = <TData = Awaited<ReturnType<typeof getUnlockedAccount>>, TError = AxiosError<unknown>>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUnlockedAccount>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUnlockedAccountQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUnlockedAccount>>> = ({ signal }) => getUnlockedAccount({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUnlockedAccount>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUnlockedAccountQueryResult = NonNullable<Awaited<ReturnType<typeof getUnlockedAccount>>>
export type GetUnlockedAccountQueryError = AxiosError<unknown>


/**
 * @summary Get the unlocked harvesting account public keys.
 */

export function useGetUnlockedAccount<TData = Awaited<ReturnType<typeof getUnlockedAccount>>, TError = AxiosError<unknown>>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUnlockedAccount>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUnlockedAccountQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Announces a transaction to the network.
The [catbuffer library](https://github.com/nemtech/catbuffer) defines the protocol to serialize and deserialize Symbol entities.
Catbuffers are integrated into [Symbol SDKs](https://nemtech.github.io/sdk.html). 
It's recommended to use SDKs instead of calling the API endpoint directly to announce transactions.

 * @summary Announce a new transaction
 */
export const announceTransaction = (
    transactionPayloadBody: TransactionPayloadBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnnounceTransactionInfoDTO>> => {
    
    
    return axios.put(
      `/transactions`,
      transactionPayloadBody,options
    );
  }



export const getAnnounceTransactionMutationOptions = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof announceTransaction>>, TError,{data: TransactionPayloadBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof announceTransaction>>, TError,{data: TransactionPayloadBody}, TContext> => {

const mutationKey = ['announceTransaction'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof announceTransaction>>, {data: TransactionPayloadBody}> = (props) => {
          const {data} = props ?? {};

          return  announceTransaction(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AnnounceTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof announceTransaction>>>
    export type AnnounceTransactionMutationBody = TransactionPayloadBody
    export type AnnounceTransactionMutationError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>

    /**
 * @summary Announce a new transaction
 */
export const useAnnounceTransaction = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof announceTransaction>>, TError,{data: TransactionPayloadBody}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof announceTransaction>>,
        TError,
        {data: TransactionPayloadBody},
        TContext
      > => {

      const mutationOptions = getAnnounceTransactionMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Returns an array of confirmed transactions.
If a transaction was announced with an alias rather than an address, the address that will be considered when querying is the one that
was resolved from the alias at confirmation time.

 * @summary Search confirmed transactions
 */
export const searchConfirmedTransactions = (
    params?: SearchConfirmedTransactionsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionPage>> => {
    
    
    return axios.get(
      `/transactions/confirmed`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSearchConfirmedTransactionsQueryKey = (params?: SearchConfirmedTransactionsParams,) => {
    return [`/transactions/confirmed`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchConfirmedTransactionsQueryOptions = <TData = Awaited<ReturnType<typeof searchConfirmedTransactions>>, TError = AxiosError<InvalidArgumentResponse>>(params?: SearchConfirmedTransactionsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchConfirmedTransactions>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchConfirmedTransactionsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchConfirmedTransactions>>> = ({ signal }) => searchConfirmedTransactions(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchConfirmedTransactions>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchConfirmedTransactionsQueryResult = NonNullable<Awaited<ReturnType<typeof searchConfirmedTransactions>>>
export type SearchConfirmedTransactionsQueryError = AxiosError<InvalidArgumentResponse>


/**
 * @summary Search confirmed transactions
 */

export function useSearchConfirmedTransactions<TData = Awaited<ReturnType<typeof searchConfirmedTransactions>>, TError = AxiosError<InvalidArgumentResponse>>(
 params?: SearchConfirmedTransactionsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchConfirmedTransactions>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getSearchConfirmedTransactionsQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns confirmed transactions information for a given array of transactionIds.
 * @summary Get confirmed trasactions information
 */
export const getConfirmedTransactions = (
    transactionIdsBody: TransactionIdsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionInfoDTO[]>> => {
    
    
    return axios.post(
      `/transactions/confirmed`,
      transactionIdsBody,options
    );
  }



export const getGetConfirmedTransactionsMutationOptions = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getConfirmedTransactions>>, TError,{data: TransactionIdsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof getConfirmedTransactions>>, TError,{data: TransactionIdsBody}, TContext> => {

const mutationKey = ['getConfirmedTransactions'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getConfirmedTransactions>>, {data: TransactionIdsBody}> = (props) => {
          const {data} = props ?? {};

          return  getConfirmedTransactions(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetConfirmedTransactionsMutationResult = NonNullable<Awaited<ReturnType<typeof getConfirmedTransactions>>>
    export type GetConfirmedTransactionsMutationBody = TransactionIdsBody
    export type GetConfirmedTransactionsMutationError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>

    /**
 * @summary Get confirmed trasactions information
 */
export const useGetConfirmedTransactions = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getConfirmedTransactions>>, TError,{data: TransactionIdsBody}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof getConfirmedTransactions>>,
        TError,
        {data: TransactionIdsBody},
        TContext
      > => {

      const mutationOptions = getGetConfirmedTransactionsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Returns confirmed transaction information given a transactionId or hash.
 * @summary Get confirmed transaction information
 */
export const getConfirmedTransaction = (
    transactionId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionInfoDTO>> => {
    
    
    return axios.get(
      `/transactions/confirmed/${transactionId}`,options
    );
  }


export const getGetConfirmedTransactionQueryKey = (transactionId: string,) => {
    return [`/transactions/confirmed/${transactionId}`] as const;
    }

    
export const getGetConfirmedTransactionQueryOptions = <TData = Awaited<ReturnType<typeof getConfirmedTransaction>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(transactionId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConfirmedTransaction>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetConfirmedTransactionQueryKey(transactionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getConfirmedTransaction>>> = ({ signal }) => getConfirmedTransaction(transactionId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(transactionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getConfirmedTransaction>>, TError, TData> & { queryKey: QueryKey }
}

export type GetConfirmedTransactionQueryResult = NonNullable<Awaited<ReturnType<typeof getConfirmedTransaction>>>
export type GetConfirmedTransactionQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get confirmed transaction information
 */

export function useGetConfirmedTransaction<TData = Awaited<ReturnType<typeof getConfirmedTransaction>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 transactionId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getConfirmedTransaction>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetConfirmedTransactionQueryOptions(transactionId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns an array of unconfirmed transactions.
 * @summary Search unconfirmed transactions
 */
export const searchUnconfirmedTransactions = (
    params?: SearchUnconfirmedTransactionsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionPage>> => {
    
    
    return axios.get(
      `/transactions/unconfirmed`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSearchUnconfirmedTransactionsQueryKey = (params?: SearchUnconfirmedTransactionsParams,) => {
    return [`/transactions/unconfirmed`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchUnconfirmedTransactionsQueryOptions = <TData = Awaited<ReturnType<typeof searchUnconfirmedTransactions>>, TError = AxiosError<InvalidArgumentResponse>>(params?: SearchUnconfirmedTransactionsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchUnconfirmedTransactions>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchUnconfirmedTransactionsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchUnconfirmedTransactions>>> = ({ signal }) => searchUnconfirmedTransactions(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchUnconfirmedTransactions>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchUnconfirmedTransactionsQueryResult = NonNullable<Awaited<ReturnType<typeof searchUnconfirmedTransactions>>>
export type SearchUnconfirmedTransactionsQueryError = AxiosError<InvalidArgumentResponse>


/**
 * @summary Search unconfirmed transactions
 */

export function useSearchUnconfirmedTransactions<TData = Awaited<ReturnType<typeof searchUnconfirmedTransactions>>, TError = AxiosError<InvalidArgumentResponse>>(
 params?: SearchUnconfirmedTransactionsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchUnconfirmedTransactions>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getSearchUnconfirmedTransactionsQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns unconfirmed transactions information for a given array of transactionIds.
 * @summary Get unconfirmed trasactions information
 */
export const getUnconfirmedTransactions = (
    transactionIdsBody: TransactionIdsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionInfoDTO[]>> => {
    
    
    return axios.post(
      `/transactions/unconfirmed`,
      transactionIdsBody,options
    );
  }



export const getGetUnconfirmedTransactionsMutationOptions = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getUnconfirmedTransactions>>, TError,{data: TransactionIdsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof getUnconfirmedTransactions>>, TError,{data: TransactionIdsBody}, TContext> => {

const mutationKey = ['getUnconfirmedTransactions'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getUnconfirmedTransactions>>, {data: TransactionIdsBody}> = (props) => {
          const {data} = props ?? {};

          return  getUnconfirmedTransactions(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetUnconfirmedTransactionsMutationResult = NonNullable<Awaited<ReturnType<typeof getUnconfirmedTransactions>>>
    export type GetUnconfirmedTransactionsMutationBody = TransactionIdsBody
    export type GetUnconfirmedTransactionsMutationError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>

    /**
 * @summary Get unconfirmed trasactions information
 */
export const useGetUnconfirmedTransactions = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getUnconfirmedTransactions>>, TError,{data: TransactionIdsBody}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof getUnconfirmedTransactions>>,
        TError,
        {data: TransactionIdsBody},
        TContext
      > => {

      const mutationOptions = getGetUnconfirmedTransactionsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Returns unconfirmed transaction information given a transactionId or hash.
 * @summary Get unconfirmed transaction information
 */
export const getUnconfirmedTransaction = (
    transactionId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionInfoDTO>> => {
    
    
    return axios.get(
      `/transactions/unconfirmed/${transactionId}`,options
    );
  }


export const getGetUnconfirmedTransactionQueryKey = (transactionId: string,) => {
    return [`/transactions/unconfirmed/${transactionId}`] as const;
    }

    
export const getGetUnconfirmedTransactionQueryOptions = <TData = Awaited<ReturnType<typeof getUnconfirmedTransaction>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(transactionId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUnconfirmedTransaction>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUnconfirmedTransactionQueryKey(transactionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUnconfirmedTransaction>>> = ({ signal }) => getUnconfirmedTransaction(transactionId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(transactionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUnconfirmedTransaction>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUnconfirmedTransactionQueryResult = NonNullable<Awaited<ReturnType<typeof getUnconfirmedTransaction>>>
export type GetUnconfirmedTransactionQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get unconfirmed transaction information
 */

export function useGetUnconfirmedTransaction<TData = Awaited<ReturnType<typeof getUnconfirmedTransaction>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 transactionId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getUnconfirmedTransaction>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetUnconfirmedTransactionQueryOptions(transactionId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns an array of transaction statuses for a given array of transaction hashes.
 * @summary Get transaction statuses
 */
export const getTransactionStatuses = (
    transactionHashesBody: TransactionHashesBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionStatusDTO[]>> => {
    
    
    return axios.post(
      `/transactionStatus`,
      transactionHashesBody,options
    );
  }



export const getGetTransactionStatusesMutationOptions = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getTransactionStatuses>>, TError,{data: TransactionHashesBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof getTransactionStatuses>>, TError,{data: TransactionHashesBody}, TContext> => {

const mutationKey = ['getTransactionStatuses'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getTransactionStatuses>>, {data: TransactionHashesBody}> = (props) => {
          const {data} = props ?? {};

          return  getTransactionStatuses(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetTransactionStatusesMutationResult = NonNullable<Awaited<ReturnType<typeof getTransactionStatuses>>>
    export type GetTransactionStatusesMutationBody = TransactionHashesBody
    export type GetTransactionStatusesMutationError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>

    /**
 * @summary Get transaction statuses
 */
export const useGetTransactionStatuses = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getTransactionStatuses>>, TError,{data: TransactionHashesBody}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof getTransactionStatuses>>,
        TError,
        {data: TransactionHashesBody},
        TContext
      > => {

      const mutationOptions = getGetTransactionStatusesMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Returns the transaction status for a given hash.
 * @summary Get transaction status
 */
export const getTransactionStatus = (
    hash: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionStatusDTO>> => {
    
    
    return axios.get(
      `/transactionStatus/${hash}`,options
    );
  }


export const getGetTransactionStatusQueryKey = (hash: string,) => {
    return [`/transactionStatus/${hash}`] as const;
    }

    
export const getGetTransactionStatusQueryOptions = <TData = Awaited<ReturnType<typeof getTransactionStatus>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(hash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTransactionStatus>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTransactionStatusQueryKey(hash);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTransactionStatus>>> = ({ signal }) => getTransactionStatus(hash, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(hash), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTransactionStatus>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTransactionStatusQueryResult = NonNullable<Awaited<ReturnType<typeof getTransactionStatus>>>
export type GetTransactionStatusQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get transaction status
 */

export function useGetTransactionStatus<TData = Awaited<ReturnType<typeof getTransactionStatus>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 hash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTransactionStatus>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetTransactionStatusQueryOptions(hash,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns an array of partial transactions.
 * @summary Search partial transactions
 */
export const searchPartialTransactions = (
    params?: SearchPartialTransactionsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionPage>> => {
    
    
    return axios.get(
      `/transactions/partial`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSearchPartialTransactionsQueryKey = (params?: SearchPartialTransactionsParams,) => {
    return [`/transactions/partial`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchPartialTransactionsQueryOptions = <TData = Awaited<ReturnType<typeof searchPartialTransactions>>, TError = AxiosError<InvalidArgumentResponse>>(params?: SearchPartialTransactionsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchPartialTransactions>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchPartialTransactionsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchPartialTransactions>>> = ({ signal }) => searchPartialTransactions(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchPartialTransactions>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchPartialTransactionsQueryResult = NonNullable<Awaited<ReturnType<typeof searchPartialTransactions>>>
export type SearchPartialTransactionsQueryError = AxiosError<InvalidArgumentResponse>


/**
 * @summary Search partial transactions
 */

export function useSearchPartialTransactions<TData = Awaited<ReturnType<typeof searchPartialTransactions>>, TError = AxiosError<InvalidArgumentResponse>>(
 params?: SearchPartialTransactionsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchPartialTransactions>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getSearchPartialTransactionsQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Announces an aggregate bonded transaction to the network.
 * @summary Announce an aggregate bonded transaction
 */
export const announcePartialTransaction = (
    transactionPayloadBody: TransactionPayloadBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnnounceTransactionInfoDTO>> => {
    
    
    return axios.put(
      `/transactions/partial`,
      transactionPayloadBody,options
    );
  }



export const getAnnouncePartialTransactionMutationOptions = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof announcePartialTransaction>>, TError,{data: TransactionPayloadBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof announcePartialTransaction>>, TError,{data: TransactionPayloadBody}, TContext> => {

const mutationKey = ['announcePartialTransaction'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof announcePartialTransaction>>, {data: TransactionPayloadBody}> = (props) => {
          const {data} = props ?? {};

          return  announcePartialTransaction(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AnnouncePartialTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof announcePartialTransaction>>>
    export type AnnouncePartialTransactionMutationBody = TransactionPayloadBody
    export type AnnouncePartialTransactionMutationError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>

    /**
 * @summary Announce an aggregate bonded transaction
 */
export const useAnnouncePartialTransaction = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof announcePartialTransaction>>, TError,{data: TransactionPayloadBody}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof announcePartialTransaction>>,
        TError,
        {data: TransactionPayloadBody},
        TContext
      > => {

      const mutationOptions = getAnnouncePartialTransactionMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Returns partial transactions information for a given array of transactionIds.
 * @summary Get partial trasactions information
 */
export const getPartialTransactions = (
    transactionIdsBody: TransactionIdsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionInfoDTO[]>> => {
    
    
    return axios.post(
      `/transactions/partial`,
      transactionIdsBody,options
    );
  }



export const getGetPartialTransactionsMutationOptions = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getPartialTransactions>>, TError,{data: TransactionIdsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof getPartialTransactions>>, TError,{data: TransactionIdsBody}, TContext> => {

const mutationKey = ['getPartialTransactions'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getPartialTransactions>>, {data: TransactionIdsBody}> = (props) => {
          const {data} = props ?? {};

          return  getPartialTransactions(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetPartialTransactionsMutationResult = NonNullable<Awaited<ReturnType<typeof getPartialTransactions>>>
    export type GetPartialTransactionsMutationBody = TransactionIdsBody
    export type GetPartialTransactionsMutationError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>

    /**
 * @summary Get partial trasactions information
 */
export const useGetPartialTransactions = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getPartialTransactions>>, TError,{data: TransactionIdsBody}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof getPartialTransactions>>,
        TError,
        {data: TransactionIdsBody},
        TContext
      > => {

      const mutationOptions = getGetPartialTransactionsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Returns partial transaction information given a transactionId or hash.
 * @summary Get partial transaction information
 */
export const getPartialTransaction = (
    transactionId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionInfoDTO>> => {
    
    
    return axios.get(
      `/transactions/partial/${transactionId}`,options
    );
  }


export const getGetPartialTransactionQueryKey = (transactionId: string,) => {
    return [`/transactions/partial/${transactionId}`] as const;
    }

    
export const getGetPartialTransactionQueryOptions = <TData = Awaited<ReturnType<typeof getPartialTransaction>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(transactionId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getPartialTransaction>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPartialTransactionQueryKey(transactionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPartialTransaction>>> = ({ signal }) => getPartialTransaction(transactionId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(transactionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPartialTransaction>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPartialTransactionQueryResult = NonNullable<Awaited<ReturnType<typeof getPartialTransaction>>>
export type GetPartialTransactionQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get partial transaction information
 */

export function useGetPartialTransaction<TData = Awaited<ReturnType<typeof getPartialTransaction>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 transactionId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getPartialTransaction>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetPartialTransactionQueryOptions(transactionId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Announces a cosignature transaction to the network.
 * @summary Announce a cosignature transaction
 */
export const announceCosignatureTransaction = (
    cosignatureBody: CosignatureBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnnounceTransactionInfoDTO>> => {
    
    
    return axios.put(
      `/transactions/cosignature`,
      cosignatureBody,options
    );
  }



export const getAnnounceCosignatureTransactionMutationOptions = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof announceCosignatureTransaction>>, TError,{data: CosignatureBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof announceCosignatureTransaction>>, TError,{data: CosignatureBody}, TContext> => {

const mutationKey = ['announceCosignatureTransaction'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof announceCosignatureTransaction>>, {data: CosignatureBody}> = (props) => {
          const {data} = props ?? {};

          return  announceCosignatureTransaction(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AnnounceCosignatureTransactionMutationResult = NonNullable<Awaited<ReturnType<typeof announceCosignatureTransaction>>>
    export type AnnounceCosignatureTransactionMutationBody = CosignatureBody
    export type AnnounceCosignatureTransactionMutationError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>

    /**
 * @summary Announce a cosignature transaction
 */
export const useAnnounceCosignatureTransaction = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof announceCosignatureTransaction>>, TError,{data: CosignatureBody}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof announceCosignatureTransaction>>,
        TError,
        {data: CosignatureBody},
        TContext
      > => {

      const mutationOptions = getAnnounceCosignatureTransactionMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Returns an array of hash locks.
 * @summary Search hash lock entries
 */
export const searchHashLock = (
    params?: SearchHashLockParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<HashLockPage>> => {
    
    
    return axios.get(
      `/lock/hash`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSearchHashLockQueryKey = (params?: SearchHashLockParams,) => {
    return [`/lock/hash`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchHashLockQueryOptions = <TData = Awaited<ReturnType<typeof searchHashLock>>, TError = AxiosError<InvalidArgumentResponse>>(params?: SearchHashLockParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchHashLock>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchHashLockQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchHashLock>>> = ({ signal }) => searchHashLock(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchHashLock>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchHashLockQueryResult = NonNullable<Awaited<ReturnType<typeof searchHashLock>>>
export type SearchHashLockQueryError = AxiosError<InvalidArgumentResponse>


/**
 * @summary Search hash lock entries
 */

export function useSearchHashLock<TData = Awaited<ReturnType<typeof searchHashLock>>, TError = AxiosError<InvalidArgumentResponse>>(
 params?: SearchHashLockParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchHashLock>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getSearchHashLockQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Gets the hash lock for a given hash.
 * @summary Get hash lock information
 */
export const getHashLock = (
    hash: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<HashLockInfoDTO>> => {
    
    
    return axios.get(
      `/lock/hash/${hash}`,options
    );
  }


export const getGetHashLockQueryKey = (hash: string,) => {
    return [`/lock/hash/${hash}`] as const;
    }

    
export const getGetHashLockQueryOptions = <TData = Awaited<ReturnType<typeof getHashLock>>, TError = AxiosError<InvalidArgumentResponse>>(hash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getHashLock>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetHashLockQueryKey(hash);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getHashLock>>> = ({ signal }) => getHashLock(hash, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(hash), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getHashLock>>, TError, TData> & { queryKey: QueryKey }
}

export type GetHashLockQueryResult = NonNullable<Awaited<ReturnType<typeof getHashLock>>>
export type GetHashLockQueryError = AxiosError<InvalidArgumentResponse>


/**
 * @summary Get hash lock information
 */

export function useGetHashLock<TData = Awaited<ReturnType<typeof getHashLock>>, TError = AxiosError<InvalidArgumentResponse>>(
 hash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getHashLock>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetHashLockQueryOptions(hash,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Gets the hash lock merkle for a given hash.
 * @summary Get hash lock merkle information
 */
export const getHashLockMerkle = (
    hash: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MerkleStateInfoDTO>> => {
    
    
    return axios.get(
      `/lock/hash/${hash}/merkle`,options
    );
  }


export const getGetHashLockMerkleQueryKey = (hash: string,) => {
    return [`/lock/hash/${hash}/merkle`] as const;
    }

    
export const getGetHashLockMerkleQueryOptions = <TData = Awaited<ReturnType<typeof getHashLockMerkle>>, TError = AxiosError<InvalidArgumentResponse>>(hash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getHashLockMerkle>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetHashLockMerkleQueryKey(hash);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getHashLockMerkle>>> = ({ signal }) => getHashLockMerkle(hash, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(hash), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getHashLockMerkle>>, TError, TData> & { queryKey: QueryKey }
}

export type GetHashLockMerkleQueryResult = NonNullable<Awaited<ReturnType<typeof getHashLockMerkle>>>
export type GetHashLockMerkleQueryError = AxiosError<InvalidArgumentResponse>


/**
 * @summary Get hash lock merkle information
 */

export function useGetHashLockMerkle<TData = Awaited<ReturnType<typeof getHashLockMerkle>>, TError = AxiosError<InvalidArgumentResponse>>(
 hash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getHashLockMerkle>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetHashLockMerkleQueryOptions(hash,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns an array of secret locks.
 * @summary Search secret lock entries
 */
export const searchSecretLock = (
    params?: SearchSecretLockParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SecretLockPage>> => {
    
    
    return axios.get(
      `/lock/secret`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSearchSecretLockQueryKey = (params?: SearchSecretLockParams,) => {
    return [`/lock/secret`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchSecretLockQueryOptions = <TData = Awaited<ReturnType<typeof searchSecretLock>>, TError = AxiosError<InvalidArgumentResponse>>(params?: SearchSecretLockParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchSecretLock>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchSecretLockQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchSecretLock>>> = ({ signal }) => searchSecretLock(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchSecretLock>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchSecretLockQueryResult = NonNullable<Awaited<ReturnType<typeof searchSecretLock>>>
export type SearchSecretLockQueryError = AxiosError<InvalidArgumentResponse>


/**
 * @summary Search secret lock entries
 */

export function useSearchSecretLock<TData = Awaited<ReturnType<typeof searchSecretLock>>, TError = AxiosError<InvalidArgumentResponse>>(
 params?: SearchSecretLockParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchSecretLock>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getSearchSecretLockQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Gets the hash lock for a given composite hash.
 * @summary Get secret lock information
 */
export const getSecretLock = (
    compositeHash: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SecretLockInfoDTO>> => {
    
    
    return axios.get(
      `/lock/secret/${compositeHash}`,options
    );
  }


export const getGetSecretLockQueryKey = (compositeHash: string,) => {
    return [`/lock/secret/${compositeHash}`] as const;
    }

    
export const getGetSecretLockQueryOptions = <TData = Awaited<ReturnType<typeof getSecretLock>>, TError = AxiosError<InvalidArgumentResponse>>(compositeHash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSecretLock>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSecretLockQueryKey(compositeHash);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSecretLock>>> = ({ signal }) => getSecretLock(compositeHash, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(compositeHash), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSecretLock>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSecretLockQueryResult = NonNullable<Awaited<ReturnType<typeof getSecretLock>>>
export type GetSecretLockQueryError = AxiosError<InvalidArgumentResponse>


/**
 * @summary Get secret lock information
 */

export function useGetSecretLock<TData = Awaited<ReturnType<typeof getSecretLock>>, TError = AxiosError<InvalidArgumentResponse>>(
 compositeHash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSecretLock>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSecretLockQueryOptions(compositeHash,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Gets the hash lock merkle for a given composite hash.
 * @summary Get secret lock merkle information
 */
export const getSecretLockMerkle = (
    compositeHash: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MerkleStateInfoDTO>> => {
    
    
    return axios.get(
      `/lock/secret/${compositeHash}/merkle`,options
    );
  }


export const getGetSecretLockMerkleQueryKey = (compositeHash: string,) => {
    return [`/lock/secret/${compositeHash}/merkle`] as const;
    }

    
export const getGetSecretLockMerkleQueryOptions = <TData = Awaited<ReturnType<typeof getSecretLockMerkle>>, TError = AxiosError<InvalidArgumentResponse>>(compositeHash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSecretLockMerkle>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetSecretLockMerkleQueryKey(compositeHash);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getSecretLockMerkle>>> = ({ signal }) => getSecretLockMerkle(compositeHash, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(compositeHash), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getSecretLockMerkle>>, TError, TData> & { queryKey: QueryKey }
}

export type GetSecretLockMerkleQueryResult = NonNullable<Awaited<ReturnType<typeof getSecretLockMerkle>>>
export type GetSecretLockMerkleQueryError = AxiosError<InvalidArgumentResponse>


/**
 * @summary Get secret lock merkle information
 */

export function useGetSecretLockMerkle<TData = Awaited<ReturnType<typeof getSecretLockMerkle>>, TError = AxiosError<InvalidArgumentResponse>>(
 compositeHash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getSecretLockMerkle>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetSecretLockMerkleQueryOptions(compositeHash,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns an array of metadata.
 * @summary Search metadata entries
 */
export const searchMetadataEntries = (
    params?: SearchMetadataEntriesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MetadataPage>> => {
    
    
    return axios.get(
      `/metadata`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSearchMetadataEntriesQueryKey = (params?: SearchMetadataEntriesParams,) => {
    return [`/metadata`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchMetadataEntriesQueryOptions = <TData = Awaited<ReturnType<typeof searchMetadataEntries>>, TError = AxiosError<InvalidArgumentResponse>>(params?: SearchMetadataEntriesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchMetadataEntries>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchMetadataEntriesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchMetadataEntries>>> = ({ signal }) => searchMetadataEntries(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchMetadataEntries>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchMetadataEntriesQueryResult = NonNullable<Awaited<ReturnType<typeof searchMetadataEntries>>>
export type SearchMetadataEntriesQueryError = AxiosError<InvalidArgumentResponse>


/**
 * @summary Search metadata entries
 */

export function useSearchMetadataEntries<TData = Awaited<ReturnType<typeof searchMetadataEntries>>, TError = AxiosError<InvalidArgumentResponse>>(
 params?: SearchMetadataEntriesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchMetadataEntries>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getSearchMetadataEntriesQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Gets the metadata for a given composite hash.
 * @summary Get metadata information
 */
export const getMetadata = (
    compositeHash: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MetadataInfoDTO>> => {
    
    
    return axios.get(
      `/metadata/${compositeHash}`,options
    );
  }


export const getGetMetadataQueryKey = (compositeHash: string,) => {
    return [`/metadata/${compositeHash}`] as const;
    }

    
export const getGetMetadataQueryOptions = <TData = Awaited<ReturnType<typeof getMetadata>>, TError = AxiosError<InvalidArgumentResponse>>(compositeHash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMetadata>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMetadataQueryKey(compositeHash);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMetadata>>> = ({ signal }) => getMetadata(compositeHash, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(compositeHash), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMetadata>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMetadataQueryResult = NonNullable<Awaited<ReturnType<typeof getMetadata>>>
export type GetMetadataQueryError = AxiosError<InvalidArgumentResponse>


/**
 * @summary Get metadata information
 */

export function useGetMetadata<TData = Awaited<ReturnType<typeof getMetadata>>, TError = AxiosError<InvalidArgumentResponse>>(
 compositeHash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMetadata>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMetadataQueryOptions(compositeHash,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Gets the metadata merkle for a given composite hash.
 * @summary Get metadata merkle information
 */
export const getMetadataMerkle = (
    compositeHash: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MerkleStateInfoDTO>> => {
    
    
    return axios.get(
      `/metadata/${compositeHash}/merkle`,options
    );
  }


export const getGetMetadataMerkleQueryKey = (compositeHash: string,) => {
    return [`/metadata/${compositeHash}/merkle`] as const;
    }

    
export const getGetMetadataMerkleQueryOptions = <TData = Awaited<ReturnType<typeof getMetadataMerkle>>, TError = AxiosError<InvalidArgumentResponse>>(compositeHash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMetadataMerkle>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMetadataMerkleQueryKey(compositeHash);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMetadataMerkle>>> = ({ signal }) => getMetadataMerkle(compositeHash, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(compositeHash), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMetadataMerkle>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMetadataMerkleQueryResult = NonNullable<Awaited<ReturnType<typeof getMetadataMerkle>>>
export type GetMetadataMerkleQueryError = AxiosError<InvalidArgumentResponse>


/**
 * @summary Get metadata merkle information
 */

export function useGetMetadataMerkle<TData = Awaited<ReturnType<typeof getMetadataMerkle>>, TError = AxiosError<InvalidArgumentResponse>>(
 compositeHash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMetadataMerkle>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMetadataMerkleQueryOptions(compositeHash,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Gets the mosaic definition for a given mosaic identifier.
 * @summary Get mosaic information
 */
export const getMosaic = (
    mosaicId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MosaicInfoDTO>> => {
    
    
    return axios.get(
      `/mosaics/${mosaicId}`,options
    );
  }


export const getGetMosaicQueryKey = (mosaicId: string,) => {
    return [`/mosaics/${mosaicId}`] as const;
    }

    
export const getGetMosaicQueryOptions = <TData = Awaited<ReturnType<typeof getMosaic>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(mosaicId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMosaic>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMosaicQueryKey(mosaicId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMosaic>>> = ({ signal }) => getMosaic(mosaicId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(mosaicId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMosaic>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMosaicQueryResult = NonNullable<Awaited<ReturnType<typeof getMosaic>>>
export type GetMosaicQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get mosaic information
 */

export function useGetMosaic<TData = Awaited<ReturnType<typeof getMosaic>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 mosaicId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMosaic>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMosaicQueryOptions(mosaicId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Gets the mosaic definition merkle for a given mosaic identifier.
 * @summary Get mosaic merkle information
 */
export const getMosaicMerkle = (
    mosaicId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MerkleStateInfoDTO>> => {
    
    
    return axios.get(
      `/mosaics/${mosaicId}/merkle`,options
    );
  }


export const getGetMosaicMerkleQueryKey = (mosaicId: string,) => {
    return [`/mosaics/${mosaicId}/merkle`] as const;
    }

    
export const getGetMosaicMerkleQueryOptions = <TData = Awaited<ReturnType<typeof getMosaicMerkle>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(mosaicId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMosaicMerkle>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMosaicMerkleQueryKey(mosaicId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMosaicMerkle>>> = ({ signal }) => getMosaicMerkle(mosaicId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(mosaicId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMosaicMerkle>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMosaicMerkleQueryResult = NonNullable<Awaited<ReturnType<typeof getMosaicMerkle>>>
export type GetMosaicMerkleQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get mosaic merkle information
 */

export function useGetMosaicMerkle<TData = Awaited<ReturnType<typeof getMosaicMerkle>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 mosaicId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMosaicMerkle>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMosaicMerkleQueryOptions(mosaicId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Gets an array of mosaics.
 * @summary Search mosaics
 */
export const searchMosaics = (
    params?: SearchMosaicsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MosaicPage>> => {
    
    
    return axios.get(
      `/mosaics`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSearchMosaicsQueryKey = (params?: SearchMosaicsParams,) => {
    return [`/mosaics`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchMosaicsQueryOptions = <TData = Awaited<ReturnType<typeof searchMosaics>>, TError = AxiosError<InvalidArgumentResponse>>(params?: SearchMosaicsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchMosaics>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchMosaicsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchMosaics>>> = ({ signal }) => searchMosaics(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchMosaics>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchMosaicsQueryResult = NonNullable<Awaited<ReturnType<typeof searchMosaics>>>
export type SearchMosaicsQueryError = AxiosError<InvalidArgumentResponse>


/**
 * @summary Search mosaics
 */

export function useSearchMosaics<TData = Awaited<ReturnType<typeof searchMosaics>>, TError = AxiosError<InvalidArgumentResponse>>(
 params?: SearchMosaicsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchMosaics>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getSearchMosaicsQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Gets an array of mosaic definition.
 * @summary Get mosaics information for an array of mosaics
 */
export const getMosaics = (
    mosaicIdsBody: MosaicIdsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MosaicInfoDTO[]>> => {
    
    
    return axios.post(
      `/mosaics`,
      mosaicIdsBody,options
    );
  }



export const getGetMosaicsMutationOptions = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getMosaics>>, TError,{data: MosaicIdsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof getMosaics>>, TError,{data: MosaicIdsBody}, TContext> => {

const mutationKey = ['getMosaics'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getMosaics>>, {data: MosaicIdsBody}> = (props) => {
          const {data} = props ?? {};

          return  getMosaics(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetMosaicsMutationResult = NonNullable<Awaited<ReturnType<typeof getMosaics>>>
    export type GetMosaicsMutationBody = MosaicIdsBody
    export type GetMosaicsMutationError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>

    /**
 * @summary Get mosaics information for an array of mosaics
 */
export const useGetMosaics = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getMosaics>>, TError,{data: MosaicIdsBody}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof getMosaics>>,
        TError,
        {data: MosaicIdsBody},
        TContext
      > => {

      const mutationOptions = getGetMosaicsMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Returns the multisig account information.
 * @summary Get multisig account information
 */
export const getAccountMultisig = (
    address: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MultisigAccountInfoDTO>> => {
    
    
    return axios.get(
      `/account/${address}/multisig`,options
    );
  }


export const getGetAccountMultisigQueryKey = (address: string,) => {
    return [`/account/${address}/multisig`] as const;
    }

    
export const getGetAccountMultisigQueryOptions = <TData = Awaited<ReturnType<typeof getAccountMultisig>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(address: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAccountMultisig>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAccountMultisigQueryKey(address);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccountMultisig>>> = ({ signal }) => getAccountMultisig(address, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(address), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAccountMultisig>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAccountMultisigQueryResult = NonNullable<Awaited<ReturnType<typeof getAccountMultisig>>>
export type GetAccountMultisigQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get multisig account information
 */

export function useGetAccountMultisig<TData = Awaited<ReturnType<typeof getAccountMultisig>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 address: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAccountMultisig>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAccountMultisigQueryOptions(address,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns the multisig account merkle information.
 * @summary Get multisig account merkle information
 */
export const getAccountMultisigMerkle = (
    address: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MerkleStateInfoDTO>> => {
    
    
    return axios.get(
      `/account/${address}/multisig/merkle`,options
    );
  }


export const getGetAccountMultisigMerkleQueryKey = (address: string,) => {
    return [`/account/${address}/multisig/merkle`] as const;
    }

    
export const getGetAccountMultisigMerkleQueryOptions = <TData = Awaited<ReturnType<typeof getAccountMultisigMerkle>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(address: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAccountMultisigMerkle>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAccountMultisigMerkleQueryKey(address);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccountMultisigMerkle>>> = ({ signal }) => getAccountMultisigMerkle(address, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(address), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAccountMultisigMerkle>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAccountMultisigMerkleQueryResult = NonNullable<Awaited<ReturnType<typeof getAccountMultisigMerkle>>>
export type GetAccountMultisigMerkleQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get multisig account merkle information
 */

export function useGetAccountMultisigMerkle<TData = Awaited<ReturnType<typeof getAccountMultisigMerkle>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 address: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAccountMultisigMerkle>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAccountMultisigMerkleQueryOptions(address,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns the multisig account graph.
 * @summary Get multisig account graph information
 */
export const getAccountMultisigGraph = (
    address: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MultisigAccountGraphInfoDTO[]>> => {
    
    
    return axios.get(
      `/account/${address}/multisig/graph`,options
    );
  }


export const getGetAccountMultisigGraphQueryKey = (address: string,) => {
    return [`/account/${address}/multisig/graph`] as const;
    }

    
export const getGetAccountMultisigGraphQueryOptions = <TData = Awaited<ReturnType<typeof getAccountMultisigGraph>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(address: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAccountMultisigGraph>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAccountMultisigGraphQueryKey(address);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccountMultisigGraph>>> = ({ signal }) => getAccountMultisigGraph(address, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(address), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAccountMultisigGraph>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAccountMultisigGraphQueryResult = NonNullable<Awaited<ReturnType<typeof getAccountMultisigGraph>>>
export type GetAccountMultisigGraphQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get multisig account graph information
 */

export function useGetAccountMultisigGraph<TData = Awaited<ReturnType<typeof getAccountMultisigGraph>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 address: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAccountMultisigGraph>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAccountMultisigGraphQueryOptions(address,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Gets an array of namespaces.
 * @summary Search namespaces
 */
export const searchNamespaces = (
    params?: SearchNamespacesParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<NamespacePage>> => {
    
    
    return axios.get(
      `/namespaces`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSearchNamespacesQueryKey = (params?: SearchNamespacesParams,) => {
    return [`/namespaces`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchNamespacesQueryOptions = <TData = Awaited<ReturnType<typeof searchNamespaces>>, TError = AxiosError<InvalidArgumentResponse>>(params?: SearchNamespacesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchNamespaces>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchNamespacesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchNamespaces>>> = ({ signal }) => searchNamespaces(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchNamespaces>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchNamespacesQueryResult = NonNullable<Awaited<ReturnType<typeof searchNamespaces>>>
export type SearchNamespacesQueryError = AxiosError<InvalidArgumentResponse>


/**
 * @summary Search namespaces
 */

export function useSearchNamespaces<TData = Awaited<ReturnType<typeof searchNamespaces>>, TError = AxiosError<InvalidArgumentResponse>>(
 params?: SearchNamespacesParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchNamespaces>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getSearchNamespacesQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Gets the namespace for a given namespace identifier.
 * @summary Get namespace information
 */
export const getNamespace = (
    namespaceId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<NamespaceInfoDTO>> => {
    
    
    return axios.get(
      `/namespaces/${namespaceId}`,options
    );
  }


export const getGetNamespaceQueryKey = (namespaceId: string,) => {
    return [`/namespaces/${namespaceId}`] as const;
    }

    
export const getGetNamespaceQueryOptions = <TData = Awaited<ReturnType<typeof getNamespace>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(namespaceId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNamespace>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNamespaceQueryKey(namespaceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNamespace>>> = ({ signal }) => getNamespace(namespaceId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(namespaceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNamespace>>, TError, TData> & { queryKey: QueryKey }
}

export type GetNamespaceQueryResult = NonNullable<Awaited<ReturnType<typeof getNamespace>>>
export type GetNamespaceQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get namespace information
 */

export function useGetNamespace<TData = Awaited<ReturnType<typeof getNamespace>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 namespaceId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNamespace>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetNamespaceQueryOptions(namespaceId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Gets the namespace merkle for a given namespace identifier.
 * @summary Get namespace merkle information
 */
export const getNamespaceMerkle = (
    namespaceId: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MerkleStateInfoDTO>> => {
    
    
    return axios.get(
      `/namespaces/${namespaceId}/merkle`,options
    );
  }


export const getGetNamespaceMerkleQueryKey = (namespaceId: string,) => {
    return [`/namespaces/${namespaceId}/merkle`] as const;
    }

    
export const getGetNamespaceMerkleQueryOptions = <TData = Awaited<ReturnType<typeof getNamespaceMerkle>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(namespaceId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNamespaceMerkle>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetNamespaceMerkleQueryKey(namespaceId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNamespaceMerkle>>> = ({ signal }) => getNamespaceMerkle(namespaceId, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(namespaceId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getNamespaceMerkle>>, TError, TData> & { queryKey: QueryKey }
}

export type GetNamespaceMerkleQueryResult = NonNullable<Awaited<ReturnType<typeof getNamespaceMerkle>>>
export type GetNamespaceMerkleQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get namespace merkle information
 */

export function useGetNamespaceMerkle<TData = Awaited<ReturnType<typeof getNamespaceMerkle>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 namespaceId: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getNamespaceMerkle>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetNamespaceMerkleQueryOptions(namespaceId,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns friendly names for namespaces.
 * @summary Get readable names for a set of namespaces
 */
export const getNamespacesNames = (
    namespaceIdsBody: NamespaceIdsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<NamespaceNameDTO[]>> => {
    
    
    return axios.post(
      `/namespaces/names`,
      namespaceIdsBody,options
    );
  }



export const getGetNamespacesNamesMutationOptions = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getNamespacesNames>>, TError,{data: NamespaceIdsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof getNamespacesNames>>, TError,{data: NamespaceIdsBody}, TContext> => {

const mutationKey = ['getNamespacesNames'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getNamespacesNames>>, {data: NamespaceIdsBody}> = (props) => {
          const {data} = props ?? {};

          return  getNamespacesNames(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetNamespacesNamesMutationResult = NonNullable<Awaited<ReturnType<typeof getNamespacesNames>>>
    export type GetNamespacesNamesMutationBody = NamespaceIdsBody
    export type GetNamespacesNamesMutationError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>

    /**
 * @summary Get readable names for a set of namespaces
 */
export const useGetNamespacesNames = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getNamespacesNames>>, TError,{data: NamespaceIdsBody}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof getNamespacesNames>>,
        TError,
        {data: NamespaceIdsBody},
        TContext
      > => {

      const mutationOptions = getGetNamespacesNamesMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Returns friendly names for accounts.
 * @summary Get readable names for a set of accountIds
 */
export const getAccountsNames = (
    addressesBody: AddressesBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccountsNamesDTO>> => {
    
    
    return axios.post(
      `/namespaces/account/names`,
      addressesBody,options
    );
  }



export const getGetAccountsNamesMutationOptions = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getAccountsNames>>, TError,{data: AddressesBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof getAccountsNames>>, TError,{data: AddressesBody}, TContext> => {

const mutationKey = ['getAccountsNames'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getAccountsNames>>, {data: AddressesBody}> = (props) => {
          const {data} = props ?? {};

          return  getAccountsNames(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetAccountsNamesMutationResult = NonNullable<Awaited<ReturnType<typeof getAccountsNames>>>
    export type GetAccountsNamesMutationBody = AddressesBody
    export type GetAccountsNamesMutationError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>

    /**
 * @summary Get readable names for a set of accountIds
 */
export const useGetAccountsNames = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getAccountsNames>>, TError,{data: AddressesBody}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof getAccountsNames>>,
        TError,
        {data: AddressesBody},
        TContext
      > => {

      const mutationOptions = getGetAccountsNamesMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Returns friendly names for mosaics.
 * @summary Get readable names for a set of mosaics
 */
export const getMosaicsNames = (
    mosaicIdsBody: MosaicIdsBody, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MosaicsNamesDTO>> => {
    
    
    return axios.post(
      `/namespaces/mosaic/names`,
      mosaicIdsBody,options
    );
  }



export const getGetMosaicsNamesMutationOptions = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getMosaicsNames>>, TError,{data: MosaicIdsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof getMosaicsNames>>, TError,{data: MosaicIdsBody}, TContext> => {

const mutationKey = ['getMosaicsNames'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof getMosaicsNames>>, {data: MosaicIdsBody}> = (props) => {
          const {data} = props ?? {};

          return  getMosaicsNames(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type GetMosaicsNamesMutationResult = NonNullable<Awaited<ReturnType<typeof getMosaicsNames>>>
    export type GetMosaicsNamesMutationBody = MosaicIdsBody
    export type GetMosaicsNamesMutationError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>

    /**
 * @summary Get readable names for a set of mosaics
 */
export const useGetMosaicsNames = <TError = AxiosError<InvalidContentResponse | InvalidArgumentResponse>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof getMosaicsNames>>, TError,{data: MosaicIdsBody}, TContext>, axios?: AxiosRequestConfig}
 ): UseMutationResult<
        Awaited<ReturnType<typeof getMosaicsNames>>,
        TError,
        {data: MosaicIdsBody},
        TContext
      > => {

      const mutationOptions = getGetMosaicsNamesMutationOptions(options);

      return useMutation(mutationOptions );
    }
    
/**
 * Gets an array of transaction statements.
 * @summary Search transaction statements
 */
export const searchReceipts = (
    params?: SearchReceiptsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransactionStatementPage>> => {
    
    
    return axios.get(
      `/statements/transaction`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSearchReceiptsQueryKey = (params?: SearchReceiptsParams,) => {
    return [`/statements/transaction`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchReceiptsQueryOptions = <TData = Awaited<ReturnType<typeof searchReceipts>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(params?: SearchReceiptsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchReceipts>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchReceiptsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchReceipts>>> = ({ signal }) => searchReceipts(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchReceipts>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchReceiptsQueryResult = NonNullable<Awaited<ReturnType<typeof searchReceipts>>>
export type SearchReceiptsQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Search transaction statements
 */

export function useSearchReceipts<TData = Awaited<ReturnType<typeof searchReceipts>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 params?: SearchReceiptsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchReceipts>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getSearchReceiptsQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Gets an array of address resolution statements.
 * @summary Get receipts address resolution statements
 */
export const searchAddressResolutionStatements = (
    params?: SearchAddressResolutionStatementsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ResolutionStatementPage>> => {
    
    
    return axios.get(
      `/statements/resolutions/address`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSearchAddressResolutionStatementsQueryKey = (params?: SearchAddressResolutionStatementsParams,) => {
    return [`/statements/resolutions/address`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchAddressResolutionStatementsQueryOptions = <TData = Awaited<ReturnType<typeof searchAddressResolutionStatements>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(params?: SearchAddressResolutionStatementsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchAddressResolutionStatements>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchAddressResolutionStatementsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchAddressResolutionStatements>>> = ({ signal }) => searchAddressResolutionStatements(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchAddressResolutionStatements>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchAddressResolutionStatementsQueryResult = NonNullable<Awaited<ReturnType<typeof searchAddressResolutionStatements>>>
export type SearchAddressResolutionStatementsQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get receipts address resolution statements
 */

export function useSearchAddressResolutionStatements<TData = Awaited<ReturnType<typeof searchAddressResolutionStatements>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 params?: SearchAddressResolutionStatementsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchAddressResolutionStatements>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getSearchAddressResolutionStatementsQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Gets an array of mosaic resolution statements.
 * @summary Get receipts mosaic resolution statements
 */
export const searchMosaicResolutionStatements = (
    params?: SearchMosaicResolutionStatementsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ResolutionStatementPage>> => {
    
    
    return axios.get(
      `/statements/resolutions/mosaic`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSearchMosaicResolutionStatementsQueryKey = (params?: SearchMosaicResolutionStatementsParams,) => {
    return [`/statements/resolutions/mosaic`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchMosaicResolutionStatementsQueryOptions = <TData = Awaited<ReturnType<typeof searchMosaicResolutionStatements>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(params?: SearchMosaicResolutionStatementsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchMosaicResolutionStatements>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchMosaicResolutionStatementsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchMosaicResolutionStatements>>> = ({ signal }) => searchMosaicResolutionStatements(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchMosaicResolutionStatements>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchMosaicResolutionStatementsQueryResult = NonNullable<Awaited<ReturnType<typeof searchMosaicResolutionStatements>>>
export type SearchMosaicResolutionStatementsQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get receipts mosaic resolution statements
 */

export function useSearchMosaicResolutionStatements<TData = Awaited<ReturnType<typeof searchMosaicResolutionStatements>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 params?: SearchMosaicResolutionStatementsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchMosaicResolutionStatements>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getSearchMosaicResolutionStatementsQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns an array of account restrictions.
 * @summary Search account restrictions
 */
export const searchAccountRestrictions = (
    params?: SearchAccountRestrictionsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccountRestrictionsPage>> => {
    
    
    return axios.get(
      `/restrictions/account`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSearchAccountRestrictionsQueryKey = (params?: SearchAccountRestrictionsParams,) => {
    return [`/restrictions/account`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchAccountRestrictionsQueryOptions = <TData = Awaited<ReturnType<typeof searchAccountRestrictions>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(params?: SearchAccountRestrictionsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchAccountRestrictions>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchAccountRestrictionsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchAccountRestrictions>>> = ({ signal }) => searchAccountRestrictions(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchAccountRestrictions>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchAccountRestrictionsQueryResult = NonNullable<Awaited<ReturnType<typeof searchAccountRestrictions>>>
export type SearchAccountRestrictionsQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Search account restrictions
 */

export function useSearchAccountRestrictions<TData = Awaited<ReturnType<typeof searchAccountRestrictions>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 params?: SearchAccountRestrictionsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchAccountRestrictions>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getSearchAccountRestrictionsQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns the account restrictions for a given address.
 * @summary Get the account restrictions
 */
export const getAccountRestrictions = (
    address: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccountRestrictionsInfoDTO>> => {
    
    
    return axios.get(
      `/restrictions/account/${address}`,options
    );
  }


export const getGetAccountRestrictionsQueryKey = (address: string,) => {
    return [`/restrictions/account/${address}`] as const;
    }

    
export const getGetAccountRestrictionsQueryOptions = <TData = Awaited<ReturnType<typeof getAccountRestrictions>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(address: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAccountRestrictions>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAccountRestrictionsQueryKey(address);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccountRestrictions>>> = ({ signal }) => getAccountRestrictions(address, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(address), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAccountRestrictions>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAccountRestrictionsQueryResult = NonNullable<Awaited<ReturnType<typeof getAccountRestrictions>>>
export type GetAccountRestrictionsQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get the account restrictions
 */

export function useGetAccountRestrictions<TData = Awaited<ReturnType<typeof getAccountRestrictions>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 address: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAccountRestrictions>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAccountRestrictionsQueryOptions(address,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns the account restrictions merkle for a given address.
 * @summary Get the account restrictions merkle
 */
export const getAccountRestrictionsMerkle = (
    address: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MerkleStateInfoDTO>> => {
    
    
    return axios.get(
      `/restrictions/account/${address}/merkle`,options
    );
  }


export const getGetAccountRestrictionsMerkleQueryKey = (address: string,) => {
    return [`/restrictions/account/${address}/merkle`] as const;
    }

    
export const getGetAccountRestrictionsMerkleQueryOptions = <TData = Awaited<ReturnType<typeof getAccountRestrictionsMerkle>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(address: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAccountRestrictionsMerkle>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetAccountRestrictionsMerkleQueryKey(address);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getAccountRestrictionsMerkle>>> = ({ signal }) => getAccountRestrictionsMerkle(address, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(address), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getAccountRestrictionsMerkle>>, TError, TData> & { queryKey: QueryKey }
}

export type GetAccountRestrictionsMerkleQueryResult = NonNullable<Awaited<ReturnType<typeof getAccountRestrictionsMerkle>>>
export type GetAccountRestrictionsMerkleQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get the account restrictions merkle
 */

export function useGetAccountRestrictionsMerkle<TData = Awaited<ReturnType<typeof getAccountRestrictionsMerkle>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 address: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getAccountRestrictionsMerkle>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetAccountRestrictionsMerkleQueryOptions(address,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns an array of mosaic restrictions.
 * @summary Search mosaic restrictions
 */
export const searchMosaicRestrictions = (
    params?: SearchMosaicRestrictionsParams, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MosaicRestrictionsPage>> => {
    
    
    return axios.get(
      `/restrictions/mosaic`,{
    ...options,
        params: {...params, ...options?.params},}
    );
  }


export const getSearchMosaicRestrictionsQueryKey = (params?: SearchMosaicRestrictionsParams,) => {
    return [`/restrictions/mosaic`, ...(params ? [params]: [])] as const;
    }

    
export const getSearchMosaicRestrictionsQueryOptions = <TData = Awaited<ReturnType<typeof searchMosaicRestrictions>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(params?: SearchMosaicRestrictionsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchMosaicRestrictions>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getSearchMosaicRestrictionsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof searchMosaicRestrictions>>> = ({ signal }) => searchMosaicRestrictions(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof searchMosaicRestrictions>>, TError, TData> & { queryKey: QueryKey }
}

export type SearchMosaicRestrictionsQueryResult = NonNullable<Awaited<ReturnType<typeof searchMosaicRestrictions>>>
export type SearchMosaicRestrictionsQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Search mosaic restrictions
 */

export function useSearchMosaicRestrictions<TData = Awaited<ReturnType<typeof searchMosaicRestrictions>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 params?: SearchMosaicRestrictionsParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof searchMosaicRestrictions>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getSearchMosaicRestrictionsQueryOptions(params,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns the mosaic restrictions for a composite hash.
 * @summary Get the mosaic restrictions
 */
export const getMosaicRestrictions = (
    compositeHash: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MosaicRestrictionDTO>> => {
    
    
    return axios.get(
      `/restrictions/mosaic/${compositeHash}`,options
    );
  }


export const getGetMosaicRestrictionsQueryKey = (compositeHash: string,) => {
    return [`/restrictions/mosaic/${compositeHash}`] as const;
    }

    
export const getGetMosaicRestrictionsQueryOptions = <TData = Awaited<ReturnType<typeof getMosaicRestrictions>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(compositeHash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMosaicRestrictions>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMosaicRestrictionsQueryKey(compositeHash);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMosaicRestrictions>>> = ({ signal }) => getMosaicRestrictions(compositeHash, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(compositeHash), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMosaicRestrictions>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMosaicRestrictionsQueryResult = NonNullable<Awaited<ReturnType<typeof getMosaicRestrictions>>>
export type GetMosaicRestrictionsQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get the mosaic restrictions
 */

export function useGetMosaicRestrictions<TData = Awaited<ReturnType<typeof getMosaicRestrictions>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 compositeHash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMosaicRestrictions>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMosaicRestrictionsQueryOptions(compositeHash,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns the mosaic restrictions merkle for a given composite hash.
 * @summary Get the mosaic restrictions merkle
 */
export const getMosaicRestrictionsMerkle = (
    compositeHash: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MerkleStateInfoDTO>> => {
    
    
    return axios.get(
      `/restrictions/mosaic/${compositeHash}/merkle`,options
    );
  }


export const getGetMosaicRestrictionsMerkleQueryKey = (compositeHash: string,) => {
    return [`/restrictions/mosaic/${compositeHash}/merkle`] as const;
    }

    
export const getGetMosaicRestrictionsMerkleQueryOptions = <TData = Awaited<ReturnType<typeof getMosaicRestrictionsMerkle>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(compositeHash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMosaicRestrictionsMerkle>>, TError, TData>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetMosaicRestrictionsMerkleQueryKey(compositeHash);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getMosaicRestrictionsMerkle>>> = ({ signal }) => getMosaicRestrictionsMerkle(compositeHash, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(compositeHash), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getMosaicRestrictionsMerkle>>, TError, TData> & { queryKey: QueryKey }
}

export type GetMosaicRestrictionsMerkleQueryResult = NonNullable<Awaited<ReturnType<typeof getMosaicRestrictionsMerkle>>>
export type GetMosaicRestrictionsMerkleQueryError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>


/**
 * @summary Get the mosaic restrictions merkle
 */

export function useGetMosaicRestrictionsMerkle<TData = Awaited<ReturnType<typeof getMosaicRestrictionsMerkle>>, TError = AxiosError<ResourceNotFoundResponse | InvalidArgumentResponse>>(
 compositeHash: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getMosaicRestrictionsMerkle>>, TError, TData>, axios?: AxiosRequestConfig}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetMosaicRestrictionsMerkleQueryOptions(compositeHash,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
